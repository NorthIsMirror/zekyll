#!/usr/bin/env zsh

zmodload zsh/zutil

typeset -gH ZKL_YES="NO"
typeset -gH ZKL_LOCAL_USER="_local"
typeset -gH ZKL_DEFAULT_PLUGIN="zkl"
typeset -gH ZKL_OUTPUT_PATH="$HOME/.zshrc_new"
typeset -gH ZKL_DO_UPDATE="0"
typeset -gH ZKL_UPDATE_ONLY="0"
typeset -gAH ZKL_UPDATED_REPOS
typeset -gH ZKL_CSTR_A="#"
typeset -gH ZKL_CSTR_B=""

#
# Data aggregation arrays
#

typeset -gaH ZKL_EMIT_ZEKYLLS
typeset -gaH ZKL_EMIT_REPOS
typeset -gaH ZKL_EMIT_FILE_NAMES
typeset -gaH ZKL_EMIT_SECTIONS
typeset -gaH ZKL_EMIT_DESCRIPTIONS

#
# Paths
#

# Problematic function_argzero
if [[ ! -o "functionargzero" ]]; then
    0="${(%):-%N}" # this gives immunity to functionargzero being unset
fi

ZKL_NAME="${${0:t}:r}"
[ -z "$ZKL_DIR" ] && ZKL_DIR="${0:h}"

if [ -z "$ZKL_HOME" ]; then
    # Ignore ZDOTDIR if user manually put Zekyll to $HOME
    if [ -d "$HOME/.$ZKL_NAME" ]; then
        typeset -gH ZKL_HOME="$HOME/.$ZKL_NAME"
    else
        typeset -gH ZKL_HOME="${ZDOTDIR:-$HOME}/.$ZKL_NAME"
    fi
fi

typeset -gH ZKL_REPOS_DIR="$ZKL_HOME/repos"
typeset -gH ZPLG_HOME_READY
typeset -gH ZKL_CUR_USER="$ZKL_LOCAL_USER"
typeset -gH ZKL_CUR_PLUGIN="$ZKL_DEFAULT_PLUGIN"

#
# Init {{{1
#

zmodload zsh/terminfo 2>/dev/null
zmodload zsh/termcap 2>/dev/null

if [[ ( -n "${terminfo[colors]}" || -n "${termcap[Co]}" ) && -z "${functions[colors]}" ]]; then
    builtin autoload -Uz colors
    colors
fi

typeset -gAH ZKLCOL
ZKLCOL=(
    "title" ""
    "pname" "${fg_bold[yellow]}"
    "uname" "${fg_bold[magenta]}"
    "keyword" "${fg_bold[green]}"
    "error" "${fg_bold[red]}"
    "p" "${fg_bold[blue]}"
    "bar" "${fg_bold[magenta]}"
    "info1" "${fg_bold[green]}"
    "info2" "${fg_bold[yellow]}"
    "uninst" "${fg_bold[blue]}"
    "success" "${fg_bold[green]}"
    "failure" "${fg_bold[red]}"
    "rst" "$reset_color"
)

# 1}}}

#
# Helper functions {{{1
#

-zkl-pinfo()  { echo "${ZKLCOL[info1]}$*${ZKLCOL[rst]}" >&2; return 0; }
-zkl-pinfo2() { echo "${ZKLCOL[info2]}$*${ZKLCOL[rst]}" >&2; return 0; }
-zkl-error()  { echo "${ZKLCOL[error]}ERROR: $*${ZKLCOL[rst]}" >&2; return 0; }
-zkl-ierror() { echo "${ZKLCOL[error]}ERROR: $*${ZKLCOL[rst]}" >&2; return 0; }

# We want zkl call to be flexible. That's why there are 6 ways
# to invoke zkl. The function detects which way is used. The 6
# ways:
#
# - user/plugin:zekyll
# - user/plugin zekyll
# - user plugin zekyll
# - user zekyll             / sensitive to "zekyll plugin"
# - user:zekyll             / sensitive to "zekyll plugin"
# - zekyll                  / sensitive to "zekyll plugin" and "zekyll user"
#
# $1 - user/plugin:zekyll(s), user/plugin, user,               user:zekyll(s), zekyll(s)
# $2 -                        zekyll(s)    plugin or zekyll(s)
# $3 -                                     zekyll(s)
#
-zkl-any-to-user-plugin-zekyll() {
    setopt localoptions extendedglob

    local user="_unknown"
    local plugin="_unknown"
    local zekyll="_unknown"

    local -a params
    params=( "$1" "$2" "$3" )
    [ -z "${params[3]}" ] && params[3]=()
    [ -z "${params[2]}" ] && params[3]=() && params[2]=()
    [ -z "${params[1]}" ] && params[3]=() && params[2]=() && params[1]=()

    set "${params[@]}"

    if [[ "$#" -eq "1" ]]; then
        # user/plugin:zekyll(s)?
        if [[ "$1" = [a-zA-Z0-9]##[/][a-zA-Z0-9]##[:][a-zA-Z0-9_]## ]]; then
            user="${1%%/*}"
            plugin="${${1%%:*}##*/}"
            zekyll="${1##*:}"
        # user:zekyll(s)?
        elif [[ "$1" = [a-zA-Z0-9]##:[a-zA-Z0-9_]## ]]; then
            user="${1%%:*}"
            plugin="$ZKL_CUR_PLUGIN"
            zekyll="${1##*:}"
        # zekyll?
        elif [[ "$1" = [a-zA-Z0-9_]## ]]; then
            user="$ZKL_CUR_USER"
            plugin="$ZKL_CUR_PLUGIN"
            zekyll="$1"
        else
            -zkl-error "Error: improper input"
        fi
    elif [[ "$#" -eq "2" ]]; then
        # user/plugin?
        if [[ "$1" = [a-zA-Z0-9]##[/][a-zA-Z0-9]## ]]; then
            # Should be zekyll(s)
            if [[ "$2" = [a-zA-Z0-9_]## ]]; then
                user="${1%%/*}"
                plugin="${1##*/}"
                zekyll="$2"
            else
                -zkl-error "Error: improper input (2)"
            fi
        # user?
        elif [[ "$1" = [a-zA-Z0-9]## ]]; then
            # Should be zekyll
            if [[ "$2" = [a-zA-Z0-9_]## ]]; then
                user="$1"
                plugin="$ZKL_CUR_PLUGIN"
                zekyll="$2"
            else
                -zkl-error "Error: improper input (3)"
            fi
        else
            -zkl-error "Error: improper input (4)"
        fi
    elif [[ "$#" -eq "3" ]]; then
        integer correct=0
        # Should be user
        if [[ "$1" = [a-zA-Z0-9]## ]]; then
            # Should be plugin
            if [[ "$2" = [a-zA-Z0-9]## ]]; then
                # Should be zekyll(s)
                if [[ "$3" = [a-zA-Z0-9_]## ]]; then
                    user="$1"
                    plugin="$2"
                    zekyll="$3"
                    correct=1
                fi
            fi
        fi

        if (( correct == 0 )); then
            -zkl-error "Error: improper input (5)"
        fi
    fi

    reply=( "$user" "$plugin" "$zekyll" )

    [[ "$user" = "_unknown" || "$plugin" = "_unknown" || "$zekyll" = "_unknown" ]] && return 1

    return 0
}

#
# Used for long zekylls, i.e. the ones with description per zekyll:
#
# zkllong psprint/zkl:ac8 These are prompt settings
# zkllong psprint:ac8 These are prompt settings
# zkllong ac8 These are prompt settings
#
# Will use $ZKL_CUR_PLUGIN and $ZKL_CUR_USER if the values aren't
# provided with zekyll
#
-zkl-any2-to-user-plugin-zekyll-desc() {
    local user plugin zekyll desc
    if [[ "$1" = [a-zA-Z0-9]##:[a-zA-Z0-9]* ]]; then
        user="${1%:*}"
        1="${1#*:}"
    elif [[ "$1" = [a-zA-Z0-9]##/[a-zA-Z0-9]##:[a-zA-Z0-9]* ]]; then
        user="${1%/*}"
        plugin="${${1#*/}%:*}"
        1="${1#*:}"
    fi

    [ -z "$user" ] && user="$ZKL_CUR_USER"
    [[ "$user" = "_unknown" || -z "$user" ]] && -zkl-error "Error: unknown user" && return 1

    [ -z "$plugin" ] && plugin="$ZKL_CUR_PLUGIN"
    [[ "$plugin" = "_unknown" || -z "$plugin" ]] && -zkl-error "Error: unknown plugin" && return 1

    # Obtain zekyll and desc
    local input="${(j: :)@}"
    desc="${input//(#s)(#b)[a-zA-Z0-9] #[a-zA-Z0-9] #[a-zA-Z0-9] #(*)/${match[1]}}"
    [ "$desc" = "$input" ] && -zkl-error "Error: Improper long input string, cannot determine description" && return 1

    local zekyll
    zekyll="${input//(#s)(#b)([a-zA-Z0-9]) #([a-zA-Z0-9]) #([a-zA-Z0-9])*/${match[1]}${match[2]}${match[3]}.}"
    [ "$zekyll" = "$input" ] && -zkl-error "Error: Improper long input string, cannot determine zekyll" && return 1
    zekyll="${zekyll%?}"
    
    reply=( "$user" "$plugin" "$zekyll" "$desc" )
    return 0
}

# This function is used for repository paths manipulations
# Basically, every repository path consists of user name and plugin name
# There are 3 formats:
# - user--plugin
# - user/plugin
# - user plugin
#
# And this function understands them all, and returns reply=( "$user" "$plugin" )
#
# $1 - user---plugin, user/plugin, user (if $2 given), or plugin (if $2 empty)
# $2 - plugin (if $1 - user - given)
#
-zkl-any-to-user-plugin() {
    # Two components given?
    # That's a pretty fast track to call this function this way
    if [ -n "$2" ]; then
        # But user name is empty?
        [ -z "$1" ] && 1="_local"

        reply=( "$1" "$2" )
        return 0
    fi

    # Rest is for single component given
    # It doesn't touch $2

    local user="${1%%/*}" plugin="${1#*/}"
    if [ "$user" = "$plugin" ]; then
        # Is it really the same plugin and user name?
        if [ "$user/$plugin" = "$1" ]; then
            reply=( "$user" "$plugin" )
            return 0
        fi

        user="${1%%---*}"
        plugin="${1#*---}"
    fi

    if [ "$user" = "$plugin" ]; then
        # Is it really the same plugin and user name?
        if [ "${user}---${plugin}" = "$1" ]; then
            reply=( "$user" "$plugin" )
            return 0
        fi
        user="_local"
    fi
    
    if [ -z "$user" ]; then
        user="_local"
    fi

    if [ -z "$plugin" ]; then
        plugin="_unknown"
    fi

    reply=( "$user" "$plugin" )
    return 0
}

# Supports all formats as input, outputs "user/plugin"
-zkl-any-to-uspl2() {
    -zkl-any-to-user-plugin "$1" "$2"
    REPLY="${reply[-2]}/${reply[-1]}"
}

# Will take uspl, uspl2, or just plugin name,
# and return colored text
-zkl-any-colorify-as-uspl2() {
    -zkl-any-to-user-plugin "$1" "$2"
    local user="${reply[-2]}" plugin="${reply[-1]}"
    local ucol="${ZKLCOL[uname]}" pcol="${ZKLCOL[pname]}"
    REPLY="${ucol}${user}${ZKLCOL[rst]}/${pcol}${plugin}${ZKLCOL[rst]}"
}

# Prepare readlink command, used e.g. for
# establishing completion's owner
-zkl-prepare-readlink() {
    REPLY=":"
    if type readlink 2>/dev/null 1>&2; then
        REPLY="readlink"
    fi
}

#
# Collapses given characters
#
-zkl-collapse-chars() {
    local chars="$1"
    if [ -n "$chars" ]; then
        local first="${chars[1]//(#m)[][*?|#~^()><\\]/\\$MATCH}"
        chars="${chars//$~first##/$first}"
    fi
    REPLY="$chars"
}

#
# Takes file name (also supports full path) and
# turns it into human readable description
#
-zkl-file-name-to-hreadable-desc() {
    REPLY="${${1:t}//-##/ }"
    if [ -z "$2" ]; then
        REPLY="${REPLY/(#b)([a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9].[A-Z])/[${match[1]}]}"
    else
        REPLY="${REPLY/(#b)([a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9].[A-Z])*/[${match[1]}] $2}"
    fi
}

#
# Typical actions on start of input:
# - preparing home directory
# - decoding input for repository and zekyll data
# - updating repository
# - detecting if "update only" mode is done
# - signaling inproper input and update mode
#
# Has two modes, zkl and zkllong. Input differs for both of them.
# For the first input, reffer to -zkl-any-to-user-plugin and for
# the second one to -zkl-any2-to-user-plugin-zekyll-desc.
#
-zkl-start-zekyll-input() {
    -zkl-prepare-home

    if [ "$1" = "zkl" ]; then
        shift
        -zkl-any-to-user-plugin-zekyll "$1" "$2" "$3" || return 2
    elif [ "$1" = "zkllong" ]; then
        shift
        -zkl-any2-to-user-plugin-zekyll-desc "$@" || return 2
    else
        return 1
    fi

    local -a tmp
    tmp=( "${reply[@]}" )
    -zkl-repo-preamble "${reply[1]}" "${reply[2]}"
    reply=( "${tmp[@]}" )

    [ "$ZKL_UPDATE_ONLY" = "1" ] && return 1
    return 0
}
# 1}}}

#
# Repository, file operations {{{1
#

-zkl-setup-repo-dir() {
    local user="$1" plugin="$2" github_path="$1/$2"
    if [ ! -d "$ZKL_REPOS_DIR/${user}---${plugin}" ]; then
        -zkl-any-colorify-as-uspl2 "$user" "$plugin"
        print "Downloading $REPLY..."

        # Return with error when any problem
        git clone --recursive https://github.com/"$github_path" "$ZKL_REPOS_DIR/${user}---${plugin}" || return 1
    fi

    return 0
}

#
# Pulls changes from origin to given repository
#
-zkl-update-repo-dir() {
    local user="$1" plugin="$2"

    -zkl-any-colorify-as-uspl2 "$user" "$plugin"
    uspl2col="$REPLY"

    if [ -d "$ZKL_REPOS_DIR/${user}---${plugin}" ]; then
        print "Updating $uspl2col..."

        (
            cd "$ZKL_REPOS_DIR/${user}---${plugin}"
            git pull
            return
        )
    else
        -zkl-error "Error: The repository $uspl2col doesn't exist"
    fi

    return 1
}

#
# Pulls changes from origin to given repository
# Guards to do it only once per plugin during session
#
-zkl-update-repo-dir-once() {
    local user="$1" plugin="$2" github_path="$1/$2"
    (( ${+ZKL_UPDATED_REPOS[$github_path]} )) && return 1
    ZKL_UPDATED_REPOS[$github_path]="1"

    -zkl-update-repo-dir "$user" "$plugin"
    return
}

-zkl-prepare-home() {
    [ -n "$ZKL_HOME_READY" ] && return
    ZKL_HOME_READY="1"

    [ ! -d "$ZKL_HOME" ] && {
        command mkdir 2>/dev/null "$ZKL_HOME"
        # For compaudit
        command chmod go-w "$ZKL_HOME"
    }
    [ ! -d "$ZKL_REPOS_DIR" ] && {
        command mkdir "$ZKL_REPOS_DIR"
        # For compaudit
        command chmod go-w "$ZKL_REPOS_DIR"
    }
}

# 1}}}

-zkl-help() {
    echo "Create file ~/.zekyllfile, and put there e.g.:
    zekyll yes
    zekyll user psprint
    zkl andromeda_software_zsh_linux_z3kyl
    zkllong ek Completion settings
    zekyll end

To generate the default file ~/.zshrc_new from zekylls 'an', 'dr', 'om',
'ed', 'as', 'of', 'tw', 'ar', 'ez', 'sh', 'li', 'nu', 'xz', '3k', 'yl' and
then from the last one, 'ek'.

The default repository used (if unspecified) is 'zkl'. Thus, with user
'psprint', the git url is https://github.com/psprint/zkl

'zekyll no' supresses any generation

Options are:
-h,--help       -- this help
-f,--file       -- zekyllfile to use (default ~/.zekyllfile)
-o,--output     -- output file to write (default ~/.zshrc_new)
-u,--update     -- update plugins before using them
--update-only   -- only update plugins, don't do generation
"
}

#
# Second parameter might be description that
# will override the one from zekyll
#
-process-zekyll-file() {
    local desc="$2"

    echo "Processing ${1:t}"
    reply=( "${(@f)"$(<$1)"}" )

    #
    # Remove vim mode lines
    #

    -zkl-collapse-chars "$ZKL_CSTR_A"
    local commentchar1="$REPLY"
    -zkl-collapse-chars "$ZKL_CSTR_B"
    local commentchar2="$REPLY"

    reply=( "${(@)reply:#$~commentchar1 #vim:*$~commentchar2}" )

    #
    # Add description line
    #

    -zkl-file-name-to-hreadable-desc "$1"
    if [ -n "$ZKL_CSTR_B" ]; then
        reply=( "$ZKL_CSTR_A $REPLY $ZKL_CSTR_B" "${reply[@]}" )
    else
        reply=( "$ZKL_CSTR_A $REPLY " "${reply[@]}" )
    fi

    # Add separating new line if it's not there
    line="${reply[-1]}"
    [ -n "$line" ] && reply+=( "" )
}

#
# Does output
#

-zkl-emit() {
    local -a output

    #
    # Aggregate
    #

    integer size="${#ZKL_EMIT_ZEKYLLS}" i
    for (( i=1; i<=size; i++ )); do
        local zekylls="${ZKL_EMIT_ZEKYLLS[i]}"
        local section="${ZKL_EMIT_SECTIONS[i]}"
        local repo="${ZKL_EMIT_REPOS[i]}"
        local file_name="${ZKL_EMIT_FILE_NAMES[i]}"
        local desc="${ZKL_EMIT_DESCRIPTIONS[i]}"

        -process-zekyll-file "${ZKL_REPOS_DIR}/${repo}/${file_name}" "$desc"
        output+=( "${reply[@]}" )
    done

    #
    # Write to file
    #

    print -rl -- "${output[@]}" > "$ZKL_OUTPUT_PATH"

    if [ "$ZKL_UPDATE_ONLY" = "0" ]; then
        -zkl-pinfo "Generated $ZKL_OUTPUT_PATH"
    fi
}

#
# We need to have repos at certain points of time
# Also need to have them updated. Common code
#

-zkl-repo-preamble() {
    local user="$1" plugin="$2"

    integer existed=0
    [ -d "$ZKL_REPOS_DIR/${user}---${plugin}" ] && existed=1

    # Possible clone
    -zkl-setup-repo-dir "$user" "$plugin"

    # Update?
    if [[ "$ZKL_DO_UPDATE" = "1" && "$existed" = "1" ]]; then
        -zkl-update-repo-dir-once "$user" "$plugin"
    fi
}

#
##
### Template calls
##
#

#
# Shows help
#
help() {
    -zkl-help
}

#
# Short zekyll processing, i.e. zekylls that are two letters
# long, passed possibly as longer strings, with allowed
# underscores, e.g. my_zekyll_generates_my_config
#
# This function takes parametes as -zkl-any-to-user-plugin-zekyll
#
zkl() {
    setopt localoptions extendedglob typesetsilent

    [ "$ZKL_YES" = "NO" ] && return

    # Strictly, this will propagate error code from -zkl-start-zekyll-input
    -zkl-start-zekyll-input "zkl" "$1" "$2" "$3" || return
    local user="${reply[-3]}" plugin="${reply[-2]}" zekyll="${reply[-1]}"

    # Allow underscores - remove them now
    zekyll="${zekyll//_/}"

    local -a zekylls zekyll_file
    local zzz line

    # Generate three-character bits
    zekylls=( ${(@s:_:)${zekyll//(#b)([a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9])/$match[1]_}} )

    -zkl-pinfo2 "\nProcessing for user $user, plugin $plugin\n"

    # Iterate over the bits
    for zzz in "${zekylls[@]}"; do
        # Skip one or two letter zekylls - they are allowed though not processed
        [[ "${#zzz}" -eq 1 || "${#zzz}" -eq 2 ]] && continue

        zekyll_file=( ${ZKL_REPOS_DIR}/${user}---${plugin}/${zzz}.[A-Z]--*(N.) )
        if [[ "${#zekyll_file}" -eq 0 ]]; then
            echo "Zekyll $zzz doesn't exist, skipping"
            continue
        fi

        local file_name="${zekyll_file[1]##*/}"
        local section="${${file_name/#???.}%%--*}"

        # Store gathered data
        ZKL_EMIT_ZEKYLLS+=( "$zekyll" )
        ZKL_EMIT_SECTIONS+=( "$section" )
        ZKL_EMIT_REPOS+=( "${user}---${plugin}" )
        ZKL_EMIT_FILE_NAMES+=( "$file_name" )
        ZKL_EMIT_DESCRIPTIONS+=( "" )
    done
}

#
# This function takes:
# zkllong               [:alnum:][:alnum:] Some text here (a description, comment)
# zkllong {user}:       [:alnum:][:alnum:] Some text here (a description, comment)
# zkllong {user}/plugin:[:alnum:][:alnum:] Some text here (a description, comment)
#
zkllong() {
    setopt localoptions extendedglob typesetsilent

    [ "$ZKL_YES" = "NO" ] && return

    # Strictly, this will propagate error code from -zkl-start-zekyll-input
    -zkl-start-zekyll-input "zkllong" "$@" || return
    local user="${reply[1]}" plugin="${reply[2]}" zekyll="${reply[3]}" desc="${reply[4]}"

    -zkl-pinfo2 "\nProcessing (long) for user $user, plugin $plugin\n"

    if [ "${#zekyll}" -eq 1 ]; then
        echo "Skipping single letter zekyll $zekyll"
        return
    fi

    zekyll_file=( ${ZKL_REPOS_DIR}/${user}---${plugin}/${zekyll}.[A-Z]--*(N.) )
    if [[ "${#zekyll_file}" -eq 0 ]]; then
        echo "Zekyll $zekyll ($desc) doesn't exist, skipping"
        return
    fi

    local file_name="${zekyll_file[1]##*/}"
    local section="${${file_name/#???.}%%--*}"

    # Store gathered data
    ZKL_EMIT_ZEKYLLS+=( "$zekyll" )
    ZKL_EMIT_SECTIONS+=( "$section" )
    ZKL_EMIT_REPOS+=( "${user}---${plugin}" )
    ZKL_EMIT_FILE_NAMES+=( "$file_name" )
    ZKL_EMIT_DESCRIPTIONS+=( "$desc" )
}

#
# Enables output
#
yes() {
    [ "$1" = "no" ] && ZKL_YES="NO" && return
    ZKL_YES="YES"
}

#
# Disables output
#
no() {
    [ "$1" = "yes" ] && ZKL_YES="YES" && return
    ZKL_YES="NO"
}

#
# Sets user to local
#
local_user() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "0" ]] && -zkl-ierror "$0 takes no argument"
    ZKL_CUR_USER="$ZKL_LOCAL_USER"
}

#
# Sets default plugin
#
default_plugin() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "0" ]] && -zkl-ierror "$0 takes no argument"
    ZKL_CUR_PLUGIN="$ZKL_DEFAULT_PLUGIN"
}

#
# Sets current user
#
user() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "1" ]] && -zkl-ierror "$0 takes argument" && local_user && return
    ZKL_CUR_USER="$1"
}

#
# Sets current plugin
#
plugin() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "1" ]] && -zkl-ierror "$0 takes argument" && default_plugin && return
    ZKL_CUR_PLUGIN="$1"
}

#
# Sets characters (opening and closing ones) used for added comments
# Resets closing characters if only opening are given
#
commentis() {
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -eq "0" || "$#" -gt "2" ]] && -zkl-ierror "$0 takes one or two arguments" && return
    ZKL_CSTR_A="$1"
    ZKL_CSTR_B="$2"
}

#
# Sets current output path
#
path() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "1" ]] && -zkl-ierror "$0 takes argument" && return
    ZKL_OUTPUT_PATH="$1"
}

#
# Loads given zekyll file
# Can take user or user/plugin, i.e. user:zekyllfile, user/plugin:zekyllfile
#
file() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    -zkl-prepare-home

    local user="$ZKL_CUR_USER"
    [ "$user" = "_unknown" ] && -zkl-error "Error: unknown user" && return

    local plugin="$ZKL_CUR_PLUGIN"
    [ "$plugin" = "_unknown" ] && -zkl-error "Error: unknown plugin" && return

    local zekyllfile="$1"
    if [[ "$1" = [a-zA-Z0-9]##:[a-zA-Z0-9]* ]]; then
        user="${1%:*}"
        zekyllfile="${1#*:}"
    elif [[ "$1" = [a-zA-Z0-9]##/[a-zA-Z0-9]##:[a-zA-Z0-9]* ]]; then
        user="${1%/*}"
        plugin="${1#*/}"
        plugin="${plugin%:*}"
        zekyllfile="${1#*:}"
    fi

    -zkl-repo-preamble "$user" "$plugin"

    [ "$ZKL_UPDATE_ONLY" = "1" ] && return

    # Now CD into given "$user" "$plugin" and source zekyllfile
    [ ! -d "$ZKL_REPOS_DIR/${user}---${plugin}" ] && -zkl-error "Repository ${user}/${plugin} doesn't exist" && return 1

    cd "$ZKL_REPOS_DIR/${user}---${plugin}"

    source "$zekyllfile"
}

#
# Emits output file
#
emit() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "0" ]] && -zkl-ierror "$0 takes no argument"
    -zkl-emit
}

#
##
### Main code
##
#

typeset -A opthash
zparseopts -E -D -A opthash f: -file: o: -output: u -update -update-only h -help || exit 1

local target="$HOME/.zekyllfile"

# HELP
if (( ${+opthash[-h]} + ${+opthash[--help]} )); then
    -zkl-help
    return 0
fi

# Update
(( ${+opthash[-u]} )) && ZKL_DO_UPDATE=1
(( ${+opthash[--update]} )) && ZKL_DO_UPDATE=1

# Update only
(( ${+opthash[--update-only]} )) && ZKL_UPDATE_ONLY=1 && ZKL_DO_UPDATE=1

# Input
(( ${+opthash[-f]} )) && target="${opthash[-f]}"
(( ${+opthash[--file]} )) && target="${opthash[--file]}"

# Output
(( ${+opthash[-o]} )) && ZKL_OUTPUT_PATH="${opthash[-o]}"
(( ${+opthash[--output]} )) && ZKL_OUTPUT_PATH="${opthash[--output]}"

echo "Zekyll file is: $target"
[ "$ZKL_UPDATE_ONLY" = "1" ] && echo "Will only perform update of repositories"
echo
echo "============================================"
cat "$target"
echo "============================================"
echo

if ! test -f "$target"; then
    echo "The file doesn't exist, aborting"
    exit 1
fi

# Check syntax
if ! zsh -n "$target"; then
    echo "Syntax errors in the file, aborting"
    exit 1
fi

echo "Press enter to continue..."
read enter

source "$target"

echo

# vim:ft=zsh
