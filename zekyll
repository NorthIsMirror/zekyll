#!/usr/bin/env zsh

zmodload zsh/zutil

setopt extendedglob typesetsilent

REPO_DIR="$HOME/.zekyll/zekyll"
source "$REPO_DIR/lib/math_functions"
source "$REPO_DIR/lib/codes_huffman"
source "$REPO_DIR/lib/coding_functions"

typeset -gH ZKL_YES="NO"
typeset -gH ZKL_LOCAL_USER="_local"
typeset -gH ZKL_DEFAULT_PLUGIN="zkl"
typeset -gH ZKL_DEFAULT_REV="master"
typeset -gH ZKL_OUTPUT_PATH="$HOME/zekyll_out/"
typeset -gH ZKL_FIXED_PATH=""
typeset -gH ZKL_DO_UPDATE="0"
typeset -gH ZKL_UPDATE_ONLY="0"
typeset -gAH ZKL_UPDATED_REPOS
typeset -gH ZKL_CSTR_A="#"
typeset -gH ZKL_CSTR_B=""
typeset -ghi ZKL_COLLISION_COUNTER=0

#
# Data aggregation arrays
#

typeset -gaH ZKL_EMIT_ZEKYLLS
typeset -gaH ZKL_EMIT_REPOS
typeset -gaH ZKL_EMIT_FILE_NAMES
typeset -gaH ZKL_EMIT_SECTIONS
typeset -gaH ZKL_EMIT_DESCRIPTIONS
typeset -gaH ZKL_EMIT_OUT_PATHS

typeset -gaHU ZKL_EMITTED_PATHS

typeset -gH ZKL_LAST_PROCESSING_USER
typeset -gH ZKL_LAST_PROCESSING_REPO
typeset -gH ZKL_LAST_PROCESSING_REV

#
# Paths
#

# Problematic function_argzero
if [[ ! -o "functionargzero" ]]; then
    0="${(%):-%N}" # this gives immunity to functionargzero being unset
fi

ZKL_NAME="${${0:t}:r}"
[ -z "$ZKL_DIR" ] && ZKL_DIR="${0:h}"

if [ -z "$ZKL_HOME" ]; then
    # Ignore ZDOTDIR if user manually put Zekyll to $HOME
    if [ -d "$HOME/.$ZKL_NAME" ]; then
        typeset -gH ZKL_HOME="$HOME/.$ZKL_NAME"
    else
        typeset -gH ZKL_HOME="${ZDOTDIR:-$HOME}/.$ZKL_NAME"
    fi
fi

typeset -gH ZKL_REPOS_DIR="$ZKL_HOME/repos"
typeset -gH ZPLG_HOME_READY
typeset -gH ZKL_CUR_USER="$ZKL_LOCAL_USER"
typeset -gH ZKL_CUR_PLUGIN="$ZKL_DEFAULT_PLUGIN"
typeset -gH ZKL_CUR_REV="master"

# Init {{{1

zmodload zsh/terminfo 2>/dev/null
zmodload zsh/termcap 2>/dev/null

if [[ ( -n "${terminfo[colors]}" || -n "${termcap[Co]}" ) && -z "${functions[colors]}" ]]; then
    builtin autoload -Uz colors
    colors
fi

typeset -gAH ZKLCOL
ZKLCOL=(
    "title" ""
    "pname" "${fg_bold[yellow]}"
    "uname" "${fg_bold[magenta]}"
    "keyword" "${fg_bold[green]}"
    "error" "${fg_bold[red]}"
    "p" "${fg_bold[blue]}"
    "bar" "${fg_bold[magenta]}"
    "info1" "${fg_bold[green]}"
    "info2" "${fg_bold[yellow]}"
    "uninst" "${fg_bold[blue]}"
    "success" "${fg_bold[green]}"
    "failure" "${fg_bold[red]}"
    "rst" "$reset_color"
)

# 1}}}
# Helper functions {{{1

-zkl-pinfo()  { echo "${ZKLCOL[info1]}$*${ZKLCOL[rst]}" >&2; return 0; }
-zkl-pinfo2() { echo "${ZKLCOL[info2]}$*${ZKLCOL[rst]}" >&2; return 0; }
-zkl-error()  { echo "${ZKLCOL[error]}ERROR: $*${ZKLCOL[rst]}" >&2; return 0; }
-zkl-ierror() { echo "${ZKLCOL[error]}ERROR: $*${ZKLCOL[rst]}" >&2; return 0; }

# We want zkl call to be flexible. That's why there are 10 ways
# to invoke zkl. The function detects which way is used. The 6
# ways:
#
# - user/repo/rev:zekyll
# - user/repo/rev zekyll
# - user/repo rev zekyll    / one of two with 3 nodes
# - user repo rev zekyll    / the only with 4 nodes
# - user/repo:zekyll
# - user/repo zekyll
# - user repo zekyll        / one of two with 3 nodes
# - user:zekyll             / sensitive to "zekyll repo"
# - user zekyll             / sensitive to "zekyll repo"
# - zekyll                  / sensitive to "zekyll repo" and "zekyll user"
#
-zkl-any-to-user-repo-rev-zekyll() {
    local user="_unknown"
    local repo="_unknown"
    local rev="_unknown"
    local zekyll="_unknown"

    local -a params
    params=( "$1" "$2" "$3" "$4" )
    [ -z "${params[4]}" ] && params[4]=()
    [ -z "${params[3]}" ] && params[4]=() && params[3]=()
    [ -z "${params[2]}" ] && params[4]=() && params[3]=() && params[2]=()
    [ -z "${params[1]}" ] && params[4]=() && params[3]=() && params[2]=() && params[1]=()

    set "${params[@]}"

    if [[ "$#" -eq "1" ]]; then
        # user/repo/rev:zekyll(s)?
        if [[ "$1" = (#b)([a-zA-Z0-9][a-zA-Z0-9-]#)[/]([a-zA-Z0-9_-]##)[/]([a-zA-Z0-9_-]##)[:]([a-zA-Z0-9_]##) ]]; then
            user="${match[1]}"
            repo="${match[2]}"
            rev="${match[3]}"
            zekyll="${match[4]}"
        # user/repo:zekyll(s)?
        elif [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]#[/][a-zA-Z0-9_-]##[:][a-zA-Z0-9_]## ]]; then
            user="${1%%/*}"
            repo="${${1%%:*}##*/}"
            rev="$ZKL_CUR_REV"
            zekyll="${1##*:}"
        # user:zekyll(s)?
        elif [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]#:[a-zA-Z0-9_]## ]]; then
            user="${1%%:*}"
            repo="$ZKL_CUR_PLUGIN"
            rev="$ZKL_CUR_REV"
            zekyll="${1##*:}"
        # zekyll?
        elif [[ "$1" = [a-zA-Z0-9_]## ]]; then
            user="$ZKL_CUR_USER"
            repo="$ZKL_CUR_PLUGIN"
            rev="$ZKL_CUR_REV"
            zekyll="$1"
        else
            -zkl-error "Error: improper input: $1"
        fi
    elif [[ "$#" -eq "2" ]]; then
        # user/repo/rev?
        if [[ "$1" = (#b)([a-zA-Z0-9][a-zA-Z0-9-]#)[/]([a-zA-Z0-9_-]##)[/]([a-zA-Z0-9_-]##) ]]; then
            user="${match[1]}"
            repo="${match[2]}"
            rev="${match[3]}"

            # Should be zekyll(s)
            if [[ "$2" = [a-zA-Z0-9_]## ]]; then
                zekyll="$2"
            else
                -zkl-error "Error: improper input (2): $1 $2"
            fi
        # user/repo?
        elif [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]#[/][a-zA-Z0-9_-]## ]]; then
            # Should be zekyll(s)
            if [[ "$2" = [a-zA-Z0-9_]## ]]; then
                user="${1%%/*}"
                repo="${1##*/}"
                rev="$ZKL_CUR_REV"
                zekyll="$2"
            else
                -zkl-error "Error: improper input (3): $1 $2"
            fi
        # user?
        elif [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]# ]]; then
            # Should be zekyll
            if [[ "$2" = [a-zA-Z0-9_]## ]]; then
                user="$1"
                repo="$ZKL_CUR_PLUGIN"
                rev="$ZKL_CUR_REV"
                zekyll="$2"
            else
                -zkl-error "Error: improper input (4): $1 $2"
            fi
        else
            -zkl-error "Error: improper input (5): $1 $2"
        fi
    elif [[ "$#" -eq "4" ]]; then
        integer correct=0
        # Should be user
        if [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]# ]]; then
            # Should be repo
            if [[ "$2" = [a-zA-Z0-9_-]## ]]; then
                # Should be rev
                if [[ "$3" = [a-zA-Z0-9_-]## ]]; then
                    # Should be zekyll(s)
                    if [[ "$4" = [a-zA-Z0-9_]## ]]; then
                        user="$1"
                        repo="$2"
                        rev="$3"
                        zekyll="$4"
                        correct=1
                    fi
                fi
            fi
        fi

        if (( correct == 0 )); then
            -zkl-error "Error: improper input (6): $1 $2 $3 $4"
        fi
    elif [[ "$#" -eq "3" ]]; then
        integer correct=0
        # user repo zekyll
        # Should be user
        if [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]# ]]; then
            user="$1"
            # Should be repo
            if [[ "$2" = [a-zA-Z0-9_-]## ]]; then
                repo="$2"
                # Should be zekyll(s)
                if [[ "$3" = [a-zA-Z0-9_]## ]]; then
                    rev="$ZKL_CUR_REV"
                    zekyll="$3"
                    correct=1
                fi
            fi
        # user/repo rev zekyll
        elif [[ "$1" = (#b)([a-zA-Z0-9][a-zA-Z0-9-]#)[/]([a-zA-Z0-9_-]##) ]]; then
            user="${match[1]}"
            repo="${match[2]}"
            # Should be rev
            if [[ "$2" = [a-zA-Z0-9_-]## ]]; then
                rev="$2"
                # Should be zekyll(s)
                if [[ "$3" = [a-zA-Z0-9_]## ]]; then
                    zekyll="$3"
                    correct=1
                fi
            fi
        fi

        if (( correct == 0 )); then
            -zkl-error "Error: improper input (7): $1 $2 $3"
        fi
    fi

    reply=( "$user" "$repo" "$rev" "$zekyll" )

    [[ "$user" = "_unknown" || "$repo" = "_unknown" || "$rev" = "_unknown" || "$zekyll" = "_unknown" ]] && return 1

    return 0
}

#
# Used for long zekylls, i.e. the ones with description per zekyll:
#
# zkllong psprint/zkl/rev:ac8 These are prompt settings
# zkllong psprint/zkl:ac8 These are prompt settings
# zkllong psprint:ac8 These are prompt settings
# zkllong ac8 These are prompt settings
#
# Will use $ZKL_CUR_PLUGIN and $ZKL_CUR_USER if the values aren't
# provided with zekyll
#
-zkl-any2-to-user-repo-rev-zekyll-desc() {
    local user repo rev zekyll desc
    if [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]#:[a-zA-Z0-9]* ]]; then
        user="${1%:*}"
        1="${1#*:}"
    elif [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]#/[a-zA-Z0-9_-]##:[a-zA-Z0-9_-][a-zA-Z0-9[:space:]_-]# ]]; then
        user="${1%/*}"
        repo="${${1#*/}%:*}"
        1="${1#*:}"
    elif [[ "$1" = (#b)([a-zA-Z0-9][a-zA-Z0-9-]#)[/]([a-zA-Z0-9_-]##)[/]([a-zA-Z0-9_-]##)[:][a-zA-Z0-9_-][a-zA-Z0-9[:space:]_-]# ]]; then
        user="${match[1]}"
        repo="${match[2]}"
        rev="${match[3]}"
        1="${1#*:}"
    fi

    # TODO: discover improper input

    [ -z "$user" ] && user="$ZKL_CUR_USER"
    [[ "$user" = "_unknown" || -z "$user" ]] && -zkl-error "Error: unknown user" && return 1

    [ -z "$repo" ] && repo="$ZKL_CUR_PLUGIN"
    [[ "$repo" = "_unknown" || -z "$repo" ]] && -zkl-error "Error: unknown repo" && return 1

    [ -z "$rev" ] && rev="$ZKL_CUR_REV"
    [[ "$rev" = "_unknown" || -z "$rev" ]] && -zkl-error "Error: unknown rev" && return 1

    # Obtain zekyll and desc
    local input="${(j: :)@}"
    desc="${input//(#s)(#b)[a-zA-Z0-9] #[a-zA-Z0-9] #[a-zA-Z0-9] #(*)/${match[1]}}"
    [ "$desc" = "$input" ] && -zkl-error "Error: Improper long input string, cannot determine description" && return 1

    local zekyll
    zekyll="${input//(#s)(#b)([a-zA-Z0-9]) #([a-zA-Z0-9]) #([a-zA-Z0-9])*/${match[1]}${match[2]}${match[3]}.}"
    [ "$zekyll" = "$input" ] && -zkl-error "Error: Improper long input string, cannot determine zekyll" && return 1
    zekyll="${zekyll%?}"
    
    reply=( "$user" "$repo" "$rev" "$zekyll" "$desc" )
    return 0
}

#
# Used by "file" template command
#
# file psprint/zkl/nounderscores:.myvimcfg
# file psprint/zkl:.myvimcfg
# file psprint:.myvimcfg
#
-zkl-any3-to-user-repo-rev-zekyllfile() {
    local user repo rev zekyllfile="$1"
    # User:.zekyllfile
    if [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]#:[~/\.a-zA-Z0-9_-]## ]]; then
        user="${1%:*}"
        zekyllfile="${1#*:}"
    # User/repo:.zekyllfile
    elif [[ "$1" = (#b)([a-zA-Z0-9][a-zA-Z0-9-]#)[/]([a-zA-Z0-9_-]##)[:]([~/\.a-zA-Z0-9_-]##) ]]; then
        user="${match[1]}"
        repo="${match[2]}"
        zekyllfile="${match[3]}"
    elif [[ "$1" = (#b)([a-zA-Z0-9][a-zA-Z0-9-]#)[/]([a-zA-Z0-9_-]##)[/]([a-zA-Z0-9_-]##)[:]([~/\.a-zA-Z0-9_-]##) ]]; then
        user="${match[1]}"
        repo="${match[2]}"
        rev="${match[3]}"
        zekyllfile="${match[4]}"
    fi

    # TODO: discover improper input

    [ -z "$user" ] && user="$ZKL_CUR_USER"
    [[ "$user" = "_unknown" || -z "$user" ]] && -zkl-error "Error: unknown user" && return 1

    [ -z "$repo" ] && repo="$ZKL_CUR_PLUGIN"
    [[ "$repo" = "_unknown" || -z "$repo" ]] && -zkl-error "Error: unknown repo" && return 1

    [ -z "$rev" ] && rev="$ZKL_CUR_REV"
    [[ "$rev" = "_unknown" || -z "$rev" ]] && -zkl-error "Error: unknown rev" && return 1

    reply=( "$user" "$repo" "$rev" "$zekyllfile" )
    return 0
}

#
# Used by "zcode" template function
#
# Will use $ZKL_CUR_PLUGIN and $ZKL_CUR_USER if the values aren't
# provided. That's the main sense of this function
#
-zkl-user-repo-rev-to-user-repo-rev-defaults() {
    local user repo rev
    # User?
    if [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]# ]]; then
        user="$1"
    # User/repo?
    elif [[ "$1" = [a-zA-Z0-9][a-zA-Z0-9-]#/[a-zA-Z0-9_-]## ]]; then
        user="${1%/*}"
        repo="${1#*/}"
    # User/repo/rev?
    elif [[ "$1" = (#b)([a-zA-Z0-9][a-zA-Z0-9-]#)[/]([a-zA-Z0-9_-]##)[/]([a-zA-Z0-9_-]##) ]]; then
        user="${match[1]}"
        repo="${match[2]}"
        rev="${match[3]}"
    elif [[ "$1" != [[:blank:]]# ]]; then
        -zkl-error "Error: improper user/repo given: $1"
        return 1
    fi

    # Rev given separately?
    if [ -n "$2" ]; then
        rev="$2"
    fi

    [ -z "$user" ] && user="$ZKL_CUR_USER"
    [[ "$user" = "_unknown" || -z "$user" ]] && -zkl-error "Error: unknown user (2), no default user set" && return 1

    [ -z "$repo" ] && repo="$ZKL_CUR_PLUGIN"
    [[ "$repo" = "_unknown" || -z "$repo" ]] && -zkl-error "Error: unknown repo (2), no default repository set" && return 1

    [ -z "$rev" ] && rev="$ZKL_CUR_REV"

    reply=( "$user" "$repo" "$rev" )
    return 0
}

# This function is used for repository paths manipulations
# Basically, every repository path consists of user name and repo name
# There are 3 formats:
# - user--repo
# - user/repo
# - user repo
#
# And this function understands them all, and returns reply=( "$user" "$repo" )
#
# $1 - user---repo, user/repo, user (if $2 given), or repo (if $2 empty)
# $2 - repo (if $1 - user - given)
#
-zkl-any-to-user-repo() {
    # Two components given?
    # That's a pretty fast track to call this function this way
    if [ -n "$2" ]; then
        # But user name is empty?
        [ -z "$1" ] && 1="_local"

        reply=( "$1" "$2" )
        return 0
    fi

    # Rest is for single component given
    # It doesn't touch $2

    local user="${1%%/*}" repo="${1#*/}"
    if [ "$user" = "$repo" ]; then
        # Is it really the same repo and user name?
        if [ "$user/$repo" = "$1" ]; then
            reply=( "$user" "$repo" )
            return 0
        fi

        user="${1%%---*}"
        repo="${1#*---}"
    fi

    if [ "$user" = "$repo" ]; then
        # Is it really the same repo and user name?
        if [ "${user}---${repo}" = "$1" ]; then
            reply=( "$user" "$repo" )
            return 0
        fi
        user="_local"
    fi
    
    if [ -z "$user" ]; then
        user="_local"
    fi

    if [ -z "$repo" ]; then
        repo="_unknown"
    fi

    reply=( "$user" "$repo" )
    return 0
}

# Supports all formats as input, outputs "user/repo"
-zkl-any-to-uspl2() {
    -zkl-any-to-user-repo "$1" "$2"
    REPLY="${reply[-2]}/${reply[-1]}"
}

# Will take uspl, uspl2, or just repo name,
# and return colored text
-zkl-any-colorify-as-uspl2() {
    -zkl-any-to-user-repo "$1" "$2"
    local user="${reply[-2]}" repo="${reply[-1]}"
    local ucol="${ZKLCOL[uname]}" pcol="${ZKLCOL[pname]}"
    REPLY="${ucol}${user}${ZKLCOL[rst]}/${pcol}${repo}${ZKLCOL[rst]}"
}

# Prepare readlink command, used e.g. for
# establishing completion's owner
-zkl-prepare-readlink() {
    REPLY=":"
    if type readlink 2>/dev/null 1>&2; then
        REPLY="readlink"
    fi
}

#
# Collapses given characters
#
-zkl-collapse-chars() {
    local chars="$1"
    if [ -n "$chars" ]; then
        local first="${chars[1]//(#m)[][*?|#~^()><\\]/\\$MATCH}"
        chars="${chars//$~first##/$first}"
    fi
    REPLY="$chars"
}

#
# Takes file name (also supports full path) and
# turns it into human readable description
#
-zkl-file-name-to-hreadable-desc() {
    REPLY="${${1:t}//-##/ }"
    if [ -z "$2" ]; then
        REPLY="${REPLY/(#b)([a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9].[A-Z])/[${match[1]}]}"
    else
        REPLY="${REPLY/(#b)([a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9].[A-Z])*/[${match[1]}] $2}"
    fi
}

#
# Typical actions on start of input:
# - preparing home directory
# - decoding input for repository and zekyll data
# - updating repository
# - detecting if "update only" mode is done
# - signaling inproper input and update mode
#
# Has three modes, zkl, zkllong, file. Input differs for all of
# them. For the first input, reffer to -zkl-any-to-user-repo-rev-zekyll
# and for the second one to -zkl-any2-to-user-repo-rev-zekyll-desc.
# Third one extends the one from -zkl-any3-to-user-repo-rev-zekyllfile.
#
-zkl-start-zekyll-input() {
    -zkl-prepare-home

    local optype="$1"
    shift

    if [ "$optype" = "zkl" ]; then
        -zkl-any-to-user-repo-rev-zekyll "$1" "$2" "$3" "$4" || return 2
    elif [ "$optype" = "zkllong" ]; then
        -zkl-any2-to-user-repo-rev-zekyll-desc "$@" || return 2
    elif [ "$optype" = "file" ]; then
        -zkl-any3-to-user-repo-rev-zekyllfile "$1" || return 2
    elif [ "$optype" = "zcode" ]; then
        -zkl-user-repo-rev-to-user-repo-rev-defaults "$1" "$2" || return 2
    else
        return 1
    fi

    local -a tmp
    tmp=( "${reply[@]}" )
    -zkl-repo-preamble "${reply[1]}" "${reply[2]}" "${reply[3]}"
    reply=( "${tmp[@]}" )

    [ "$ZKL_UPDATE_ONLY" = "1" ] && return 1
    return 0
}

# 1}}}
# Repository, file operations {{{1

-zkl-setup-repo-dir() {
    local user="$1" repo="$2" rev="$3" github_path="$1/$2"
    if [ ! -d "$ZKL_REPOS_DIR/${user}---${repo}---${rev}" ]; then
        -zkl-any-colorify-as-uspl2 "$user" "$repo"
        print "Downloading $REPLY..."

        # Return with error when any problem
        git clone --recursive https://github.com/"$github_path" "$ZKL_REPOS_DIR/${user}---${repo}---${rev}" || return 1

        # Also return with error when any problem
        git -C "$ZKL_REPOS_DIR/${user}---${repo}---${rev}" checkout "$rev" || return 1
    fi

    return 0
}

#
# Pulls changes from origin to given repository
#
-zkl-update-repo-dir() {
    local user="$1" repo="$2" rev="$3"

    -zkl-any-colorify-as-uspl2 "$user" "$repo"
    uspl2col="$REPLY"

    if [ -d "$ZKL_REPOS_DIR/${user}---${repo}---${rev}" ]; then
        print "Updating $uspl2col rev. $rev..."

        (
            cd "$ZKL_REPOS_DIR/${user}---${repo}---${rev}"
            git pull
            return
        )
    else
        -zkl-error "Error: The repository $uspl2col (rev. $rev) doesn't exist"
    fi

    return 1
}

#
# Pulls changes from origin to given repository
# Guards to do it only once per repo during session
#
-zkl-update-repo-dir-once() {
    local user="$1" repo="$2" rev="$3" github_path="$1/$2"
    (( ${+ZKL_UPDATED_REPOS[$github_path]} )) && return 1
    ZKL_UPDATED_REPOS[$github_path]="1"

    -zkl-update-repo-dir "$user" "$repo" "$rev"
    return
}

-zkl-prepare-home() {
    [ -n "$ZKL_HOME_READY" ] && return
    ZKL_HOME_READY="1"

    [ ! -d "$ZKL_HOME" ] && {
        command mkdir 2>/dev/null "$ZKL_HOME"
        # For compaudit
        command chmod go-w "$ZKL_HOME"
    }
    [ ! -d "$ZKL_REPOS_DIR" ] && {
        command mkdir "$ZKL_REPOS_DIR"
        # For compaudit
        command chmod go-w "$ZKL_REPOS_DIR"
    }
}

# 1}}}

-zkl-help() {
    echo "Create file ~/.zekyllfile, and put there e.g.:
    zekyll yes
    zekyll user psprint
    zkl andromeda_software_zsh_linux_z3kyl
    zkllong ek Completion settings
    zekyll end

To generate the default file ~/.zshrc_new from zekylls 'an', 'dr', 'om',
'ed', 'as', 'of', 'tw', 'ar', 'ez', 'sh', 'li', 'nu', 'xz', '3k', 'yl' and
then from the last one, 'ek'.

The default repository used (if unspecified) is 'zkl'. Thus, with user
'psprint', the git url is https://github.com/psprint/zkl

'zekyll no' supresses any generation

Options are:
-h,--help       -- this help
-f,--file       -- zekyllfile to use (default ~/.zekyllfile)
-o,--output     -- output file to write (default ~/.zshrc_new)
-u,--update     -- update repos before using them
--update-only   -- only update repos, don't do generation
"
}

#
# Second parameter might be description that
# will override the one from zekyll
#
-process-zekyll-file() {
    local desc="$2"

    echo "Processing ${1:t}"
    reply=( "${(@f)"$(<$1)"}" )

    #
    # Remove vim mode lines
    #

    -zkl-collapse-chars "$ZKL_CSTR_A"
    local commentchar1="$REPLY"
    -zkl-collapse-chars "$ZKL_CSTR_B"
    local commentchar2="$REPLY"

    reply=( "${(@)reply:#$~commentchar1 #vim:*$~commentchar2}" )

    #
    # Add description line
    #

    if [ -z "$desc" ]; then
        -zkl-file-name-to-hreadable-desc "$1"
        desc="$REPLY"
    fi
    if [ -n "$ZKL_CSTR_B" ]; then
        reply=( "$ZKL_CSTR_A $desc $ZKL_CSTR_B" "${reply[@]}" )
    else
        reply=( "$ZKL_CSTR_A $desc" "${reply[@]}" )
    fi

    # Add separating new line if it's not there
    line="${reply[-1]}"
    [ -n "$line" ] && reply+=( "" )
}

#
# Creates needed directories, appends "out" if needed
#
-prepare-output-path() {
    local input_path="$1"
    input_path="${input_path## ##}"
    input_path="${input_path%% ##}"
    local output_path="${input_path%%/##}"

    # Case where "//*" given
    if [[ -z "$output_path" && -n "$input_path" ]]; then
        output_path="/"
    fi

    # Case where empty (containing only blanks) path given
    if [ -z "$input_path" ]; then
        input_path="./"
        output_path="."
    fi

    if [[ ( ! -d "$input_path" && ! -f "$input_path" ) && "${input_path%/}" != "${input_path}" ]]; then
        # Obtained not-existing directory, create it and provide file name: "out"
        command mkdir -p "$input_path"
        output_path="${output_path}/out"
    elif [[ ( ! -d "$input_path" && ! -f "$input_path" ) && "${input_path%/}" = "${input_path}" ]]; then
        # Obtained not-existing file name, provide that its directory exists
        # If there is no parent directory, :h will return "."
        command mkdir -p "${input_path:h}"
    elif [ -d "$input_path" ]; then
        # Obtained directory, provide file name: "out"
        output_path="${output_path}/out"
    elif [ -f "$input_path" ]; then
        :
    fi

    REPLY="$output_path"
}

# $1 - full path
# $2 - file name
#
# Result is $1:h/$2 or $1/$2
# The second case when $1 already points to directory
-merge-paths() {
    if [ -d "$1" ]; then
        REPLY="$1/$2"
    else
        REPLY="${1:h}/$2"
    fi
    return 0
}

#
# Does output
#

-zkl-emit() {
    local -a output

    ZKL_LAST_PROCESSING_USER=""
    ZKL_LAST_PROCESSING_REPO=""
    ZKL_LAST_PROCESSING_REV=""

    # Maps demanded file paths to actually written to.
    #
    # The point is that every path may be used for each whole emit once.
    # Paths used for the first time are stored in ZKL_EMITTED_PATHS and not
    # used for the second time for another emit. The hash here holds substitute
    # file paths for cases where a collision occurs. Every collision bumps up
    # ZKL_COLLISION_COUNTER and path formed this way is stored in the hash in
    # question, to be valid across one emit. This means that collisions in
    # general are counted, not collisions of single path.
    local -A paths_map

    #
    # Establish and prepare general_path
    #

    local general_path="$ZKL_FIXED_PATH"
    [ -z "$general_path" ] && general_path="$ZKL_OUTPUT_PATH"
    -prepare-output-path "$general_path"
    general_path="$REPLY"

    #
    # Aggregate
    #

    local -A already_written
    integer size="${#ZKL_EMIT_ZEKYLLS}" i a
    local selected_section
    local -a secs
    secs=( A B C D E F G H I J K L M N O P Q R S T U V W X Y Z )

    for (( a=1; a<=26; a++ )); do
        selected_section="${secs[a]}"

        for (( i=1; i<=size; i++ )); do
            local zekylls="${ZKL_EMIT_ZEKYLLS[i]}"
            local section="${ZKL_EMIT_SECTIONS[i]}"
            local repo="${ZKL_EMIT_REPOS[i]}"
            local file_name="${ZKL_EMIT_FILE_NAMES[i]}"
            local desc="${ZKL_EMIT_DESCRIPTIONS[i]}"
            local out_path="${ZKL_EMIT_OUT_PATHS[i]}"

            [ "$selected_section" != "$section" ] && continue

            if [[ "$repo" = (#b)([a-zA-Z0-9][a-zA-Z0-9-]#)---([a-zA-Z0-9_-]##)---([a-zA-Z0-9_-]##) ]]; then
                local tmp_user="${match[1]}" tmp_repo="${match[2]}" tmp_rev="${match[3]}"
                if [[ "$ZKL_LAST_PROCESSING_USER" != "$tmp_user" || "$ZKL_LAST_PROCESSING_REPO" != "$tmp_repo" || "$ZKL_LAST_PROCESSING_REV" != "$tmp_rev" ]]; then
                    local c1="${ZKLCOL[error]}" c2="${ZKLCOL[info2]}"
                    -zkl-pinfo2 "\nProcessing for user ${c1}$tmp_user${c2}, repo ${c1}$tmp_repo${c2}, rev ${c1}$tmp_rev${c2}\n"
                fi
                ZKL_LAST_PROCESSING_USER="$tmp_user"
                ZKL_LAST_PROCESSING_REPO="$tmp_repo"
                ZKL_LAST_PROCESSING_REV="$tmp_rev"
            fi

            -process-zekyll-file "${ZKL_REPOS_DIR}/${repo}/${file_name}" "$desc"
            output=( "${reply[@]}" )

            #
            # Establish output path
            #

            # out_path is established to contain file name, currently it cannot contain any path
            # general_path is already prepared, i.e. its directory exists
            local specific_path="$out_path"
            [ -n "$specific_path" ] && { -merge-paths "$general_path" "${specific_path:t}"; specific_path="$REPLY"; }
            [ -z "$specific_path" ] && specific_path="$general_path"
            [ -n "$ZKL_FIXED_PATH" ] && specific_path="$general_path"
            -prepare-output-path "$specific_path"
            specific_path="$REPLY"

            if [ -z "${paths_map[$specific_path]}" ]; then
                # No assigned path yet, can use original path unmodified?
                if [ "${ZKL_EMITTED_PATHS[(r)$specific_path]}" != "$specific_path" ]; then
                    # Can use original path unmodified
                    paths_map[$specific_path]="$specific_path"
                    ZKL_EMITTED_PATHS+=( "$specific_path" )
                else
                    # Emitting to the same file more than one time
                    # Have to generate custom path and store it for current "emit session"
                    ZKL_COLLISION_COUNTER+=1
                    local specific_path_orig="$specific_path"
                    integer counter=1
                    while (( 1 )); do
                        specific_path="${specific_path_orig}---${counter}"
                        if [ "${ZKL_EMITTED_PATHS[(r)$specific_path]}" != "$specific_path" ]; then
                            # Found first free custom path
                            break
                        fi
                        counter+=1
                    done

                    # Can use newly created path
                    paths_map[$specific_path_orig]="$specific_path"
                    ZKL_EMITTED_PATHS+=( "$specific_path" )
                fi
            else
                # Reuse path assigned to this emit session
                specific_path="${paths_map[$specific_path]}"
            fi

            #
            # Write to file
            #

            if [ "${already_written[$specific_path]}" = "1" ]; then
                print -rl -- "${output[@]}" >> "$specific_path"
            else
                already_written[$specific_path]="1"
                print -rl -- "${output[@]}" > "$specific_path"
            fi
        done
    done

    ZKL_EMIT_ZEKYLLS=( )
    ZKL_EMIT_SECTIONS=( )
    ZKL_EMIT_REPOS=( )
    ZKL_EMIT_FILE_NAMES=( )
    ZKL_EMIT_OUT_PATHS=( )
    ZKL_EMIT_DESCRIPTIONS=( )

    if [ "$ZKL_UPDATE_ONLY" = "0" ]; then
        -zkl-pinfo "Generated $ZKL_OUTPUT_PATH"
    fi
}

#
# We need to have repos at certain points of time
# Also need to have them updated. Common code
#

-zkl-repo-preamble() {
    local user="$1" repo="$2" rev="$3"

    integer existed=0
    [ -d "$ZKL_REPOS_DIR/${user}---${repo}---${rev}" ] && existed=1

    # Possible clone
    -zkl-setup-repo-dir "$user" "$repo" "$rev"

    # Update?
    if [[ "$ZKL_DO_UPDATE" = "1" && "$existed" = "1" ]]; then
        -zkl-update-repo-dir-once "$user" "$repo" "$rev"
    fi
}

#
##
### Template calls
##
#

#
# Shows help
#
help() {
    -zkl-help
}

#
# Short zekyll processing, i.e. zekylls that are two letters
# long, passed possibly as longer strings, with allowed
# underscores, e.g. my_zekyll_generates_my_config
#
# This function takes parametes as -zkl-any-to-user-repo-rev-zekyll
#
zkl() {
    [ "$ZKL_YES" = "NO" ] && return

    # Strictly, this will propagate error code from -zkl-start-zekyll-input
    -zkl-start-zekyll-input "zkl" "$1" "$2" "$3" "$4" || return
    local user="${reply[1]}" repo="${reply[2]}" rev="${reply[3]}" zekyll="${reply[4]}"

    # Allow underscores - remove them now
    zekyll="${zekyll//_/}"

    local -a zekylls zekyll_file
    local zzz line

    # Generate three-character bits
    zekylls=( ${(@s:_:)${zekyll//(#b)([a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9])/$match[1]_}} )

    # Iterate over the bits
    for zzz in "${zekylls[@]}"; do
        # Skip one or two letter zekylls - they are allowed though not processed
        [[ "${#zzz}" -eq 1 || "${#zzz}" -eq 2 ]] && continue

        zekyll_file=( ${ZKL_REPOS_DIR}/${user}---${repo}---${rev}/${zzz}.[A-Z]--*(N.) )
        if [[ "${#zekyll_file}" -eq 0 ]]; then
            echo "Zekyll $zzz doesn't exist, skipping"
            continue
        fi

        local file_name="${zekyll_file[1]##*/}"
        local section="${${file_name/#???.}%%--*}"

        # Store gathered data
        ZKL_EMIT_ZEKYLLS+=( "$zekyll" )
        ZKL_EMIT_SECTIONS+=( "$section" )
        ZKL_EMIT_REPOS+=( "${user}---${repo}---${rev}" )
        ZKL_EMIT_FILE_NAMES+=( "$file_name" )
        ZKL_EMIT_OUT_PATHS+=( "" )
        ZKL_EMIT_DESCRIPTIONS+=( "" )
    done
}

#
# This function takes:
# zkllong               [:alnum:][:alnum:] Some text here (a description, comment)
# zkllong {user}:       [:alnum:][:alnum:] Some text here (a description, comment)
# zkllong {user}/repo:[:alnum:][:alnum:] Some text here (a description, comment)
#
zkllong() {
    [ "$ZKL_YES" = "NO" ] && return

    # Strictly, this will propagate error code from -zkl-start-zekyll-input
    -zkl-start-zekyll-input "zkllong" "$@" || return
    local user="${reply[1]}" repo="${reply[2]}" rev="${reply[3]}" zekyll="${reply[4]}" desc="${reply[5]}"

    if [ "${#zekyll}" -eq 1 ]; then
        echo "Skipping single letter zekyll $zekyll"
        return
    fi

    if [ "${#zekyll}" -eq 2 ]; then
        echo "Skipping two letter zekyll $zekyll"
        return
    fi

    zekyll_file=( ${ZKL_REPOS_DIR}/${user}---${repo}---${rev}/${zekyll}.[A-Z]--*(N.) )
    if [[ "${#zekyll_file}" -eq 0 ]]; then
        echo "Zekyll $zekyll ($desc) doesn't exist, skipping"
        return
    fi

    local file_name="${zekyll_file[1]##*/}"
    local section="${${file_name/#???.}%%--*}"

    # Store gathered data
    ZKL_EMIT_ZEKYLLS+=( "$zekyll" )
    ZKL_EMIT_SECTIONS+=( "$section" )
    ZKL_EMIT_REPOS+=( "${user}---${repo}---${rev}" )
    ZKL_EMIT_FILE_NAMES+=( "$file_name" )
    ZKL_EMIT_OUT_PATHS+=( "" )
    ZKL_EMIT_DESCRIPTIONS+=( "$desc" )
}

zcode() {
    local zcode
    [ -n "$1" ] && zcode="$1" || return 0

    if [[ "$zcode" != (#b)([0-9]##)/([a-z0-9]##) ]]; then
        echo "Improper zcode: $1"
        return 1
    fi

    integer index="${match[1]}"
    local code="${match[2]}" zekylls

    set_index "$index"
    get_zekylls_for_code "$zcode"
    zekylls_str="$REPLY"

    local specific_path
    local -A mdata
    mdata=( "${reply[@]}" )

    if [ -n "${mdata[ref]}" ]; then
        print "Zcode meta-data/ref: ${mdata[ref]}"
    fi

    if [ -n "${mdata[file]}" ]; then
        print "Zcode meta-data/file: ${mdata[file]}"
        specific_path="${mdata[file]}"
    fi

    if [ -n "${mdata[repo]}" ]; then
        print "Zcode meta-data/repo: ${mdata[repo]}"
    fi

    # Strictly, this will propagate error code from -zkl-start-zekyll-input
    -zkl-start-zekyll-input "zcode" "${mdata[repo]}" "${mdata[ref]}" || return
    local user="${reply[1]}" repo="${reply[2]}" rev="${reply[3]}"

    # Allow underscores - remove them now
    zekylls_str="${zekylls_str//_/}"

    local -a zekylls zekyll_file
    local zzz line

    # Generate three-character bits
    zekylls=( ${(@s:_:)${zekylls_str//(#b)([a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9])/$match[1]_}} )

    # Iterate over the bits
    for zzz in "${zekylls[@]}"; do
        # Skip one or two letter zekylls - they are allowed though not processed
        [[ "${#zzz}" -eq 1 || "${#zzz}" -eq 2 ]] && continue

        zekyll_file=( ${ZKL_REPOS_DIR}/${user}---${repo}---${rev}/${zzz}.[A-Z]--*(N.) )
        if [[ "${#zekyll_file}" -eq 0 ]]; then
            echo "Zekyll $zzz doesn't exist, skipping"
            continue
        fi

        local file_name="${zekyll_file[1]##*/}"
        local section="${${file_name/#???.}%%--*}"

        # Store gathered data
        ZKL_EMIT_ZEKYLLS+=( "$zekylls_str" )
        ZKL_EMIT_SECTIONS+=( "$section" )
        ZKL_EMIT_REPOS+=( "${user}---${repo}---${rev}" )
        ZKL_EMIT_FILE_NAMES+=( "$file_name" )
        ZKL_EMIT_OUT_PATHS+=( "$specific_path" )
        ZKL_EMIT_DESCRIPTIONS+=( "" )
    done
}

#
# Enables output
#
yes() {
    [ "$1" = "no" ] && ZKL_YES="NO" && return
    ZKL_YES="YES"
}

#
# Disables output
#
no() {
    [ "$1" = "yes" ] && ZKL_YES="YES" && return
    ZKL_YES="NO"
}

#
# Sets user to local
#
local_user() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "0" ]] && -zkl-ierror "$0 takes no argument"
    ZKL_CUR_USER="$ZKL_LOCAL_USER"
}

#
# Sets repo to default
#
default_repo() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "0" ]] && -zkl-ierror "$0 takes no argument"
    ZKL_CUR_PLUGIN="$ZKL_DEFAULT_PLUGIN"
}

#
# Sets rev to default
#
default_rev() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "0" ]] && -zkl-ierror "$0 takes no argument"
    ZKL_CUR_REV="$ZKL_DEFAULT_REV"
}

#
# Sets current user
#
user() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "1" ]] && -zkl-ierror "$0 takes one argument" && local_user && return
    ZKL_CUR_USER="$1"
}

#
# Sets current repo
#
repo() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "1" ]] && -zkl-ierror "$0 takes one argument" && default_repo && return
    ZKL_CUR_PLUGIN="$1"
}

#
# Sets current rev
#
rev() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "1" ]] && -zkl-ierror "$0 takes one argument" && default_rev && return
    ZKL_CUR_REV="$1"
}

#
# Sets characters (opening and closing ones) used for added comments
# Resets closing characters if only opening are given
#
commentis() {
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -eq "0" || "$#" -gt "2" ]] && -zkl-ierror "$0 takes one or two arguments" && return
    ZKL_CSTR_A="$1"
    ZKL_CSTR_B="$2"
}

#
# Sets current output path
#
path() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "1" ]] && -zkl-ierror "$0 takes argument" && return
    ZKL_OUTPUT_PATH="$1"
}

#
# Sets current output path
#
fixedpath() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "1" ]] && -zkl-ierror "$0 takes argument" && return
    ZKL_FIXED_PATH="$1"
}

#
# Loads given zekyll file
# Can take user or user/repo, i.e. user:zekyllfile, user/repo:zekyllfile
#
file() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    # Strictly, this will propagate error code from -zkl-start-zekyll-input
    -zkl-start-zekyll-input "file" "$1" || return
    local user="${reply[1]}" repo="${reply[2]}" rev="${reply[3]}" zekyllfile="${reply[4]}"

    # Expand leading ~
    zekyllfile="${zekyllfile/(#s)~/$HOME}"

    # Now CD into given "$user" "$repo" and source zekyllfile
    [ ! -d "$ZKL_REPOS_DIR/${user}---${repo}---${rev}" ] && -zkl-error "Repository ${user}/${repo} rev. $rev doesn't exist" && return 1

    cd "$ZKL_REPOS_DIR/${user}---${repo}---${rev}"

    local bkp_user="$ZKL_CUR_USER" bkp_repo="$ZKL_CUR_PLUGIN" bkp_rev="$ZKL_CUR_REV"
    ZKL_CUR_USER="$user"
    ZKL_CUR_PLUGIN="$repo"
    ZKL_CUR_REV="$rev"

    source "$zekyllfile"

    ZKL_CUR_USER="$bkp_user"
    ZKL_CUR_PLUGIN="$bkp_repo"
    ZKL_CUR_REV="$bkp_rev"
}

#
# Emits output file
#
emit() {
    # Quick exit when not generating
    [ "$ZKL_YES" = "NO" ] && return

    [[ "$#" -ne "0" ]] && -zkl-ierror "$0 takes no argument"
    -zkl-emit
}

#
##
### Main code
##
#

typeset -A opthash
zparseopts -E -D -A opthash f: -file: o: -output: u -update -update-only h -help || exit 1

local target="$HOME/.zekyllfile"

# HELP
if (( ${+opthash[-h]} + ${+opthash[--help]} )); then
    -zkl-help
    return 0
fi

# Update
(( ${+opthash[-u]} )) && ZKL_DO_UPDATE=1
(( ${+opthash[--update]} )) && ZKL_DO_UPDATE=1

# Update only
(( ${+opthash[--update-only]} )) && ZKL_UPDATE_ONLY=1 && ZKL_DO_UPDATE=1

# Input
(( ${+opthash[-f]} )) && target="${opthash[-f]}"
(( ${+opthash[--file]} )) && target="${opthash[--file]}"

# Output
(( ${+opthash[-o]} )) && ZKL_OUTPUT_PATH="${opthash[-o]}"
(( ${+opthash[--output]} )) && ZKL_OUTPUT_PATH="${opthash[--output]}"

echo "Zekyll file is: $target"
[ "$ZKL_UPDATE_ONLY" = "1" ] && echo "Will only perform update of repositories"
echo
echo "============================================"
cat "$target"
echo "============================================"
echo

if ! test -f "$target"; then
    echo "The file doesn't exist, aborting"
    exit 1
fi

# Check syntax
if ! zsh -n "$target"; then
    echo "Syntax errors in the file, aborting"
    exit 1
fi

echo "Press enter to continue..."
read enter

source "$target"

echo

# vim:ft=zsh
