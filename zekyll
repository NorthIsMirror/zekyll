#!/usr/bin/env zsh

zmodload zsh/zutil

typeset -gH ZKL_YES="NO"
typeset -gH ZKL_LOCAL_USER="_local"
typeset -gH ZKL_DEFAULT_PLUGIN="zkl"
typeset -gaH ZKL_OUTPUT
typeset -gH ZKL_OUTPUT_PATH="$HOME/.zshrc_new"
typeset -gH ZKL_DO_UPDATE="0"
typeset -gH ZKL_UPDATE_ONLY="0"
typeset -gAH ZKL_UPDATED_REPOS
typeset -gH ZKL_CSTR_A="#"
typeset -gH ZKL_CSTR_B=""

# Problematic function_argzero
if [[ ! -o "functionargzero" ]]; then
    0="${(%):-%N}" # this gives immunity to functionargzero being unset
fi

ZKL_NAME="${${0:t}:r}"
[ -z "$ZKL_DIR" ] && ZKL_DIR="${0:h}"

if [ -z "$ZKL_HOME" ]; then
    # Ignore ZDOTDIR if user manually put Zekyll to $HOME
    if [ -d "$HOME/.$ZKL_NAME" ]; then
        typeset -gH ZKL_HOME="$HOME/.$ZKL_NAME"
    else
        typeset -gH ZKL_HOME="${ZDOTDIR:-$HOME}/.$ZKL_NAME"
    fi
fi

typeset -gH ZKL_REPOS_DIR="$ZKL_HOME/repos"
typeset -gH ZPLG_HOME_READY
typeset -gH ZKL_CUR_USER="$ZKL_LOCAL_USER"
typeset -gH ZKL_CUR_PLUGIN="$ZKL_DEFAULT_PLUGIN"

#
# Init {{{1
#

zmodload zsh/terminfo 2>/dev/null
zmodload zsh/termcap 2>/dev/null

if [[ ( -n "${terminfo[colors]}" || -n "${termcap[Co]}" ) && -z "${functions[colors]}" ]]; then
    builtin autoload -Uz colors
    colors
fi

typeset -gAH ZPLG_COL
ZPLG_COL=(
    "title" ""
    "pname" "${fg_bold[yellow]}"
    "uname" "${fg_bold[magenta]}"
    "keyword" "${fg_bold[green]}"
    "error" "${fg_bold[red]}"
    "p" "${fg_bold[blue]}"
    "bar" "${fg_bold[magenta]}"
    "info" "${fg_bold[green]}"
    "uninst" "${fg_bold[blue]}"
    "success" "${fg_bold[green]}"
    "failure" "${fg_bold[red]}"
    "rst" "$reset_color"
)

# 1}}}

#
# Helper functions {{{1
#

-zkl-error() {
    echo "$*" >&2
}

# We want zkl call to be flexible. That's why there are 6 ways
# to invoke zkl. The function detects which way is used. The 6
# ways:
#
# - user/plugin:zekyll
# - user/plugin zekyll
# - user plugin zekyll
# - user zekyll             / sensitive to "zekyll plugin"
# - user:zekyll             / sensitive to "zekyll plugin"
# - zekyll                  / sensitive to "zekyll plugin" and "zekyll user"
#
# $1 - user/plugin:zekyll(s), user/plugin, user,               user:zekyll(s), zekyll(s)
# $2 -                        zekyll(s)    plugin or zekyll(s)
# $3 -                                     zekyll(s)
#
-zkl-any-to-user-plugin-zekyll() {
    setopt localoptions extendedglob

    local user="_unknown"
    local plugin="_unknown"
    local zekyll="_unknown"

    local -a params
    params=( "$1" "$2" "$3" )
    [ -z "${params[3]}" ] && params[3]=()
    [ -z "${params[2]}" ] && params[3]=() && params[2]=()
    [ -z "${params[1]}" ] && params[3]=() && params[2]=() && params[1]=()

    set "${params[@]}"

    if [[ "$#" -eq "1" ]]; then
        # user/plugin:zekyll(s)?
        if [[ "$1" = [a-zA-Z0-9]##[/][a-zA-Z0-9]##[:][a-zA-Z0-9_]## ]]; then
            user="${1%%/*}"
            plugin="${${1%%:*}##*/}"
            zekyll="${1##*:}"
        # user:zekyll(s)?
        elif [[ "$1" = [a-zA-Z0-9]##:[a-zA-Z0-9_]## ]]; then
            user="${1%%:*}"
            plugin="$ZKL_CUR_PLUGIN"
            zekyll="${1##*:}"
        # zekyll?
        elif [[ "$1" = [a-zA-Z0-9_]## ]]; then
            user="$ZKL_CUR_USER"
            plugin="$ZKL_CUR_PLUGIN"
            zekyll="$1"
        else
            -zkl-error "Error: improper input"
        fi
    elif [[ "$#" -eq "2" ]]; then
        # user/plugin?
        if [[ "$1" = [a-zA-Z0-9]##[/][a-zA-Z0-9]## ]]; then
            # Should be zekyll(s)
            if [[ "$2" = [a-zA-Z0-9_]## ]]; then
                user="${1%%/*}"
                plugin="${1##*/}"
                zekyll="$2"
            else
                -zkl-error "Error: improper input (2)"
            fi
        # user?
        elif [[ "$1" = [a-zA-Z0-9]## ]]; then
            # Should be zekyll
            if [[ "$2" = [a-zA-Z0-9_]## ]]; then
                user="$1"
                plugin="$ZKL_CUR_PLUGIN"
                zekyll="$2"
            else
                -zkl-error "Error: improper input (3)"
            fi
        else
            -zkl-error "Error: improper input (4)"
        fi
    elif [[ "$#" -eq "3" ]]; then
        integer correct=0
        # Should be user
        if [[ "$1" = [a-zA-Z0-9]## ]]; then
            # Should be plugin
            if [[ "$2" = [a-zA-Z0-9]## ]]; then
                # Should be zekyll(s)
                if [[ "$3" = [a-zA-Z0-9_]## ]]; then
                    user="$1"
                    plugin="$2"
                    zekyll="$3"
                    correct=1
                fi
            fi
        fi

        if (( correct == 0 )); then
            -zkl-error "Error: improper input (5)"
        fi
    fi

    reply=( "$user" "$plugin" "$zekyll" )

    return 0
}

# This function is used for repository paths manipulations
# Basically, every repository path consists of user name and plugin name
# There are 3 formats:
# - user--plugin
# - user/plugin
# - user plugin
#
# And this function understands them all, and returns reply=( "$user" "$plugin" )
#
# $1 - user---plugin, user/plugin, user (if $2 given), or plugin (if $2 empty)
# $2 - plugin (if $1 - user - given)
#
-zkl-any-to-user-plugin() {
    # Two components given?
    # That's a pretty fast track to call this function this way
    if [ -n "$2" ]; then
        # But user name is empty?
        [ -z "$1" ] && 1="_local"

        reply=( "$1" "$2" )
        return 0
    fi

    # Rest is for single component given
    # It doesn't touch $2

    local user="${1%%/*}" plugin="${1#*/}"
    if [ "$user" = "$plugin" ]; then
        # Is it really the same plugin and user name?
        if [ "$user/$plugin" = "$1" ]; then
            reply=( "$user" "$plugin" )
            return 0
        fi

        user="${1%%---*}"
        plugin="${1#*---}"
    fi

    if [ "$user" = "$plugin" ]; then
        # Is it really the same plugin and user name?
        if [ "${user}---${plugin}" = "$1" ]; then
            reply=( "$user" "$plugin" )
            return 0
        fi
        user="_local"
    fi
    
    if [ -z "$user" ]; then
        user="_local"
    fi

    if [ -z "$plugin" ]; then
        plugin="_unknown"
    fi

    reply=( "$user" "$plugin" )
    return 0
}

# Supports all formats as input, outputs "user/plugin"
-zkl-any-to-uspl2() {
    -zkl-any-to-user-plugin "$1" "$2"
    REPLY="${reply[-2]}/${reply[-1]}"
}

# Will take uspl, uspl2, or just plugin name,
# and return colored text
-zkl-any-colorify-as-uspl2() {
    -zkl-any-to-user-plugin "$1" "$2"
    local user="${reply[-2]}" plugin="${reply[-1]}"
    local ucol="${ZPLG_COL[uname]}" pcol="${ZPLG_COL[pname]}"
    REPLY="${ucol}${user}${ZPLG_COL[rst]}/${pcol}${plugin}${ZPLG_COL[rst]}"
}

# Prepare readlink command, used e.g. for
# establishing completion's owner
-zkl-prepare-readlink() {
    REPLY=":"
    if type readlink 2>/dev/null 1>&2; then
        REPLY="readlink"
    fi
}

# 1}}}

#
# Repository, file operations {{{1
#

-zkl-setup-repo-dir() {
    local user="$1" plugin="$2" github_path="$1/$2"
    if [ ! -d "$ZKL_REPOS_DIR/${user}---${plugin}" ]; then
        -zkl-any-colorify-as-uspl2 "$user" "$plugin"
        print "Downloading $REPLY..."

        # Return with error when any problem
        git clone --recursive https://github.com/"$github_path" "$ZKL_REPOS_DIR/${user}---${plugin}" || return 1
    fi

    return 0
}

#
# Pulls changes from origin to given repository
#
-zkl-update-repo-dir() {
    local user="$1" plugin="$2"

    -zkl-any-colorify-as-uspl2 "$user" "$plugin"
    uspl2col="$REPLY"

    if [ -d "$ZKL_REPOS_DIR/${user}---${plugin}" ]; then
        print "Updating $uspl2col..."

        (
            cd "$ZKL_REPOS_DIR/${user}---${plugin}"
            git pull
            return
        )
    else
        -zkl-error "The repository $uspl2col doesn't exist"
    fi

    return 1
}

#
# Pulls changes from origin to given repository
# Guards to do it only once per plugin during session
#
-zkl-update-repo-dir-once() {
    local user="$1" plugin="$2" github_path="$1/$2"
    (( ${+ZKL_UPDATED_REPOS[$github_path]} )) && return 1
    ZKL_UPDATED_REPOS[$github_path]="1"

    -zkl-update-repo-dir "$user" "$plugin"
    return
}

-zkl-prepare-home() {
    [ -n "$ZKL_HOME_READY" ] && return
    ZKL_HOME_READY="1"

    [ ! -d "$ZKL_HOME" ] && {
        command mkdir 2>/dev/null "$ZKL_HOME"
        # For compaudit
        command chmod go-w "$ZKL_HOME"
    }
    [ ! -d "$ZKL_REPOS_DIR" ] && {
        command mkdir "$ZKL_REPOS_DIR"
        # For compaudit
        command chmod go-w "$ZKL_REPOS_DIR"
    }
}

# 1}}}

-zkl-help() {
    echo "Create file ~/.zekyllfile, and put there e.g.:
    zekyll yes
    zekyll user psprint
    zkl andromeda_software_zsh_linux_z3kyl
    zkllong ek Completion settings
    zekyll end

To generate the default file ~/.zshrc_new from zekylls 'an', 'dr', 'om',
'ed', 'as', 'of', 'tw', 'ar', 'ez', 'sh', 'li', 'nu', 'xz', '3k', 'yl' and
then from the last one, 'ek'.

The default repository used (if unspecified) is 'zkl'. Thus, with user
'psprint', the git url is https://github.com/psprint/zkl

'zekyll no' supresses any generation

Options are:
-h,--help       -- this help
-f,--file       -- zekyllfile to use (default ~/.zekyllfile)
-o,--output     -- output file to write (default ~/.zshrc_new)
-u,--update     -- update plugins before using them
--update-only   -- only update plugins, don't do generation
"
}

#
# Second parameter might be description that
# will override the one from zekyll
#
-process-zekyll-file() {
    local desc="$2"

    echo "Processing ${1:t}"
    reply=( "${(@f)"$(<$1)"}" )

    # Remove vim mode lines
    reply=( "${(@)reply:#\# #vim:*}" )

    # Add description line
    local line
    if [ -z "$desc" ]; then
        line="${1:t}"
        line="${line//-##/ }"
        line="${line/(#b)([a-zA-Z0-9][a-zA-Z0-9])/[${match[1]}]}"
    else
        line="${1:t}"
        line="${line//-##/ }"
        line="${line/(#b)([a-zA-Z0-9][a-zA-Z0-9])*/[${match[1]}] $desc}"
    fi
    if [ -n "$ZKL_CSTR_B" ]; then
        reply=( "$ZKL_CSTR_A $line $ZKL_CSTR_B" "${reply[@]}" )
    else
        reply=( "$ZKL_CSTR_A $line" "${reply[@]}" )
    fi

    # Add separating new line if it's not there
    line="${reply[-1]}"
    [ -n "$line" ] && reply+=( "" )
}

#
# Does output
#

-zkl-end() {
    print -rl -- "${ZKL_OUTPUT[@]}" > "$ZKL_OUTPUT_PATH"
    ZKL_OUTPUT=( )
}

#
# We need to have repos at certain points of time
# Also need to have them updated. Common code
#

-zkl-repo-preamble() {
    local user="$1" plugin="$2"

    integer existed=0
    [ -d "$ZKL_REPOS_DIR/${user}---${plugin}" ] && existed=1

    # Possible clone
    -zkl-setup-repo-dir "$user" "$plugin"

    # Update?
    if [[ "$ZKL_DO_UPDATE" = "1" && "$existed" = "1" ]]; then
        -zkl-update-repo-dir-once "$user" "$plugin"
    fi
}

#
# Sets character used for added comments
#
commentis() {
    ZKL_CSTR_A="$1"
    ZKL_CSTR_B="$2"
}

#
# Short zekyll processing, i.e. zekylls that are two letters
# long, passed possibly as longer strings, with allowed
# underscores, e.g. my_zekyll_generates_my_config
#
zkl() {
    setopt localoptions extendedglob typesetsilent

    [ "$ZKL_YES" = "NO" ] && return

    -zkl-prepare-home
    -zkl-any-to-user-plugin-zekyll "$1" "$2" "$3"
    local user="${reply[-3]}" plugin="${reply[-2]}" zekyll="${reply[-1]}"

    -zkl-repo-preamble "$user" "$plugin"

    [ "$ZKL_UPDATE_ONLY" = "1" ] && return

    # Allow underscores - remove them now
    zekyll="${zekyll//_/}"

    local -a zekylls fragment zekyll_file
    local zz line

    # Generate two-character bits
    zekylls=( ${(@s:_:)${zekyll//(#b)([a-zA-Z0-9][a-zA-Z0-9])/$match[1]_}} )

    echo "\nProcessing for user $user, plugin $plugin\n"

    # Iterate over the bits
    for zz in "${zekylls[@]}"; do
        # Skip one letter zekylls - they are allowed though not processed
        [ "${#zz}" -eq 1 ] && continue

        zekyll_file=( ${ZKL_REPOS_DIR}/${user}---${plugin}/${zz}--*(N.) )
        if [[ "${#zekyll_file}" -eq 0 ]]; then
            echo "Zekyll $zz doesn't exist, skipping"
            continue
        fi

        -process-zekyll-file "${zekyll_file[1]}"

        ZKL_OUTPUT+=( "${reply[@]}" )
    done
}

#
# This function takes:
# zkllong [:alnum:][:alnum:] Some text here (a description, comment)
#
# Thus, user has to be set
#
zkllong() {
    setopt localoptions extendedglob typesetsilent

    [ "$ZKL_YES" = "NO" ] && return

    -zkl-prepare-home

    local user="$ZKL_CUR_USER"
    if [ "$user" = "_unknown" ]; then
        -zkl-error "Error: unknown user"
    fi

    local plugin="$ZKL_CUR_PLUGIN"
    if [ "$plugin" = "_unknown" ]; then
        -zkl-error "Error: unknown plugin"
    fi

    -zkl-repo-preamble "$user" "$plugin"

    [ "$ZKL_UPDATE_ONLY" = "1" ] && return

    # Obtain zekyll (single one)
    local input="$*"
    local desc
    desc="${input//(#b)[a-zA-Z0-9] #[a-zA-Z0-9](*)/${match[1]}}"
    desc="${desc## ##}"
    local zekyll
    zekyll="${input//(#b)([a-zA-Z0-9]) #([a-zA-Z0-9])*/${match[1]}${match[2]}}"

    echo "\nProcessing (long) for user $user, plugin $plugin\n"

    if [ "${#zekyll}" -eq 1 ]; then
        echo "Skipping single letter zekyll $zekyll"
        return
    fi

    zekyll_file=( ${ZKL_REPOS_DIR}/${user}---${plugin}/${zekyll}--*(N.) )
    if [[ "${#zekyll_file}" -eq 0 ]]; then
        echo "Zekyll $zekyll ($desc) doesn't exist, skipping"
        return
    fi

    -process-zekyll-file "${zekyll_file[1]}" "$desc"

    ZKL_OUTPUT+=( "${reply[@]}" )
}

#
# Control function
# Sets current user or plugin
# Triggers output generation
# Can also output help (somone would like to see
# help triggered from zekyllfile?)
# Sets output target file
# etc.
#
zekyll() {
    # Quick exit when not generating
    [ "$1" = "yes" ] && ZKL_YES="YES" && return
    [ "$1" = "no" ] && ZKL_YES="NO" && return
    [ "$ZKL_YES" = "NO" ] && return

    # All functions from now on will not change these values globally
    local -a match mbegin mend
    local MATCH; integer MBEGIN MEND

    case "$1" in
        (help)
            -zkl-help
            ;;
        (user)
            ZKL_CUR_USER="$2"
            ;;
        (plugin)
            ZKL_CUR_PLUGIN="$2"
            ;;
        (output)
            ZKL_OUTPUT_PATH="$2"
            ;;
        (end)
            -zkl-end
            ;;
        (local)
            ZKL_CUR_USER="$ZKL_LOCAL_USER"
            ;;
    esac
}

typeset -A opthash
zparseopts -E -D -A opthash f: -file: o: -output: u -update -update-only h -help || exit 1

local target="$HOME/.zekyllfile"

# HELP
if (( ${+opthash[-h]} + ${+opthash[--help]} )); then
    -zkl-help
    return 0
fi

# Update
(( ${+opthash[-u]} )) && ZKL_DO_UPDATE=1
(( ${+opthash[--update]} )) && ZKL_DO_UPDATE=1

# Update only
(( ${+opthash[--update-only]} )) && ZKL_UPDATE_ONLY=1 && ZKL_DO_UPDATE=1

# Input
(( ${+opthash[-f]} )) && target="${opthash[-f]}"
(( ${+opthash[--file]} )) && target="${opthash[--file]}"

# Output
(( ${+opthash[-o]} )) && ZKL_OUTPUT_PATH="${opthash[-o]}"
(( ${+opthash[--output]} )) && ZKL_OUTPUT_PATH="${opthash[--output]}"

echo "Zekyll file is: $target"
[ "$ZKL_UPDATE_ONLY" = "1" ] && echo "Will only perform update of repositories"
echo
echo "============================================"
cat "$target"
echo "============================================"
echo

if ! test -f "$target"; then
    echo "The file doesn't exist, aborting"
    exit 1
fi

# Check syntax
if ! zsh -n "$target"; then
    echo "Syntax errors in the file, aborting"
    exit 1
fi

echo "Press enter to continue..."
read enter

source "$target"

echo
if [ "$ZKL_UPDATE_ONLY" = "0" ]; then
    echo "Generated $ZKL_OUTPUT_PATH"
fi

# vim:ft=zsh
