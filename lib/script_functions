# Helper functions
pinfo()   { print -- "${fg_bold[green]}$*$reset_color"; }
pinfon()  { print -n -- "${fg_bold[green]}$*$reset_color"; }
pinfo2()  { print -- "${fg_bold[yellow]}$*$reset_color"; }
pinfo2n() { print -n -- "${fg_bold[yellow]}$*$reset_color"; }
perror()  { print -- "${fg_bold[red]}$*$reset_color" >&2; }
perrorn() { print -n -- "${fg_bold[red]}$*$reset_color" >&2; }

qprint()  { quiet || print -- "$*"; }
qprintn() { quiet || print -n -- "$*"; }
qinfo()   { quiet || print -- "${fg_bold[green]}$*$reset_color"; }
qinfon()  { quiet || print -n -- "${fg_bold[green]}$*$reset_color"; }
qinfo2()  { quiet || print -- "${fg_bold[yellow]}$*$reset_color"; }
qinfo2n() { quiet || print -n -- "${fg_bold[yellow]}$*$reset_color"; }
qerror()  { quiet || print -- "${fg_bold[red]}$*$reset_color" >&2; }
qerrorn() { quiet || print -n -- "${fg_bold[red]}$*$reset_color" >&2; }

clearinput() { repeat 10; do read -rs -k 1 -t; done; }

#
# Standard outputs
#

dry-mode-msg() { [ "$ZKL_PERFORM_WRITE" = "0" ] && pinfo2 "= Dry mode =" || perror "= Actual mode (not-dry) ="; }
help-opts()  { pinfo "Options are:"; }
help-cd()    { print -- "-c/--cd             -- ask for working directory, otherwise it's current directory"; }
help-dry()   { print -- "-w/--write          -- actual operation mode - else it is always dry-run mode"; }
help-git()   { print -- "-g/--git            -- perform operations with git (to update repository not just files)"; }
help-path()  { print -- "-p/--path [path]    -- work in given path (don't ask for it)"; }
help-zkl()   { print -- "-z/--zkl [zekylls]  -- process given zekylls"; }
help-zkls()  { print -- "-z/--zkl [zekylls]  -- source zekylls"; }
help-zkld()  { print -- "-Z/--Zkl [zekylls]  -- destination zekylls"; }
help-dft()   { print -- "-d/--default        -- use \$ZEKYLL_DEFAULT_REPO if available as path specification (don't ask)"; }
help-repo()  { print -- "-r/--repo           -- use given repo as path specification (don't ask)"; }
help-index() { print -- "-i/--index [index]  -- work on given index"; }
help-rsize() { print -- "-s/--size [size]    -- resize to given size"; }
help-quiet() { print -- "-q/--quiet          -- try to not output any messages, just do the job"; }
help-verb()  { print -- "-v/--verbose        -- be more verbose"; }
help-nansi() { print -- "-n/--noansi         -- don't use colors in output"; }
help-sect()  { print -- "--section           -- use given section name when e.g. creating zekylls"; }
help-desc()  { print -- "--desc              -- use given description when e.g. creating zekylls"; }
help-cons()  { print -- "--consistent        -- check if index is consistent, output inconsistent files/zekylls"; }
help-list()  { print -- "--list              -- list files belonging to index, even inconsistent ones"; }

#
# Returns if quiet mode
#

quiet() {
    [ "$ZKL_QUIET" = "0" ] && return 1 || return 0
}

#
# Returns if source zekylls given
#

src() {
    [ -z "$ZKL_ZEKYLLS" ] && return 1 || return 0
}
#
# Returns if target zekylls given
#

tgt() {
    [ -z "$ZKL_TARGET_ZEKYLLS" ] && return 1 || return 0
}

#
# Turns colors on and off
#
noansi() {
    if [ "$ZKL_NOANSI" = "1" ]; then
        local k
        for k in "${(@k)fg}"; do
            fg[$k]=""
        done
        for k in "${(@k)fg_bold}"; do
            fg_bold[$k]=""
        done
        reset_color=""
        for k in "${(@k)ZKLCOL}"; do
            ZKLCOL[$k]=""
        done
    fi
}

#
# Detects duplicates in given array
#

detect_duplicates() {
    local -a sorted
    sorted=( "${(on)@}" )

    integer dups=0

    local prev="" i
    for i in "${sorted[@]}"; do
        if [ "$prev" = "$i" ]; then
            quiet || echo "Duplicate zekyll found: $i" >&2
            dups=1
        fi
        prev="$i"
    done

    return $dups
}

#
# Read destination path
#

read_destination_path() {
    local zekylls_path="$1"

    while (( 1 )); do
        pinfo "Where are zekylls located? (default: current directory \".\"):"

        vared -cp "Enter path: " zekylls_path

        if [ -z "$zekylls_path" ]; then
            zekylls_path="."
        fi

        if ! test -d "$zekylls_path"; then
            perror "Path doesn't exist, try again"
            continue
        fi

        break
    done

    REPLY="$zekylls_path"
    return 0
}

#
# Read repository spec
#

read_repo() {
    local repo_spec="$1"

    while (( 1 )); do
        vared -cp "Enter user/name or just user: " repo_spec

        if [[ "$repo_spec" != [a-zA-Z0-9][a-zA-Z0-9-]#[/][a-zA-Z0-9_-]## && "$repo_spec" != [a-zA-Z0-9][a-zA-Z0-9-]# ]]; then
            perror "Incorrect repository spec. It can contain letters, numbers, underscores and hyphens."
            continue
        fi

        get_path_from_repo "$repo_spec"
        if ! test -d "$REPLY"; then
            perror "Repository doesn't exist, try again"
            continue
        fi

        break
    done

    REPLY="$repo_spec"

    return 0
}

#
# Resolves path according to various rules and sources
#
resolve_path() {
    # If -d/--default is given, then this means: do exactly the
    # same but without prompting for path, but fallback to this
    # if ZEKYLL_DEFAULT_REPO is empty (or when ZKL_PATH is set
    # meaning user provided a path; this is used in zkl-mv where
    # prompt might be demanded even with path provided, via -c
    # option; other tools don't call this function when they
    # already have path)

    integer ask=1
    [ "$ZKL_DEFAULT" = 1 ] && ask=0
    [[ -z "$ZEKYLL_DEFAULT_REPO" || -n "$ZKL_PATH" ]] && ask=1

    [[ -n "$ZEKYLL_DEFAULT_REPO" && -z "$ZKL_PATH" ]] && { get_path_from_repo "$ZEKYLL_DEFAULT_REPO"; ZKL_PATH="$REPLY"; }

    (( ask )) && { read_destination_path "$ZKL_PATH" || return 1 }

    return 0
}

#
# This function translates repo to path, but
# also asks for the repo if conditions are
# meet
#
resolve_repo() {
    integer ask=1
    [[ "$ZKL_DEFAULT" = 1 && -n "$ZEKYLL_DEFAULT_REPO" ]] && ask=0
    [ -n "$ZKL_REPO" ] && ask=0

    # -r/--repo has precedence
    local repo="$ZEKYLL_DEFAULT_REPO"
    [ -n "$ZKL_REPO" ] && repo="$ZKL_REPO"

    if (( ask )); then
        # Will propose the repo (if it's set)
        read_repo "$repo" || return 1
        repo="$REPLY"
    fi

    get_path_from_repo "$repo"
    [ -d "$REPLY" ] && return 0 || return 1
}

#
# CD to path and show files there
#
cd_will_work_on() {
    [ -d "$1" ] || { perror "Error: path '$1' doesn't exist"; return 1 }

    cd "$1"

    # Silent mode
    [ "$2" = "-s" ] && return 0

    print
    pinfo2 "Will work on following files:"
    print

    local -a listing
    listing=( "${(@f)"$( ls -1 | pr -3 -e8 -f -l 1000 -t)"}" )
    listing=( "${listing[@]:#*$'\C-L'*}" )
    print -rl -- "${listing[@]}"

    print

    return 0
}

#
# Returns physicall path for given repo string
#
get_path_from_repo() {
    local user="${1%/*}"
    local repo="${1#*/}"

    # No repo given? Use "zkl"
    if [ "${1//\//}" = "$1" ]; then
        repo="zkl"
    fi

    REPLY="$ZKL_REPOS_DIR/${user}---${repo}"
}

#
# Returns physicall path for given user and repo
#
get_path_from_user_repo() {
    [ "$2" = "" ] && 2="zkl"
    REPLY="$ZKL_REPOS_DIR/${1}---${2}"
}

#
# Iterates over given zekylls, rejects non-existing ones,
# saves file names (returned in reply2) and sections (reply3)
#
filter_for_existing_zekylls() {
    local -a existing sections files
    local zekyll
    for zekyll in "$@"; do
        zekyll_file=( ${zekyll}.[A-Z]--*(N.) )
        if [[ "$#zekyll_file" -eq 0 ]]; then
            perror "No such zekyll $zekyll"
        else
            existing+=( "$zekyll" )
            files+=( "${zekyll_file[1]}" )

            if [[ "${zekyll_file[1]}" = (#b)${zekyll}.([A-Z])--* ]]; then
                sections+=( "${match[1]}" )
            else
                sections+=( "" )
                perror "Warning: suspicious zekyll $zekyll"
            fi
        fi
    done

    typeset -ga reply2 reply3
    reply=( "${existing[@]}" )
    reply2=( "${files[@]}" )
    reply3=( "${sections[@]}" )
}

#
# Converts lists of zekylls, files and sections into
# section order
#
three_to_section_order() {
    local -a zekylls files sections out_zekylls out_files out_sections
    integer size="$1"
    shift

    zekylls=( "${@[1,size]}" ) ; files=( "${@[1+size,size*2]}" ) ; sections=( "${@[1+2*size,size*3]}" )

    integer a i secsize="${#section_letters}"
    for (( a=1; a<=secsize; a++ )); do
        selected_section="${section_letters[a]}"
        for (( i=1; i<=size; i++ )); do
            [ "$selected_section" != "${sections[i]#.}" ] && continue

            out_zekylls+=( "${zekylls[i]}" )
            out_files+=( "${files[i]}" )
            out_sections+=( "${sections[i]}" )
        done
    done

    typeset -ga reply2 reply3
    reply=( "${out_zekylls[@]}" ) ; reply2=( "${out_files[@]}" ) ; reply3=( "${out_sections[@]}" )
}

#
# Sets ZKL_INDEX_ZEKYLLS array which contains all
# zekylls that potentially can be part of the
# index
#
set_index() {
    integer index="$1"

    ZKL_INDEX_ZEKYLLS=( )

    # Compute first element pointed to by index
    integer first=$(( (index-1)*150 ))

    integer i
    for (( i=first; i<=(first+150-1); i ++ )); do
        # Convert the number to base 36 with leading zeros
        convert_integer_to_base_36 "$i"
        ZKL_INDEX_ZEKYLLS+=( "$REPLY" )
        #print "$REPLY $i"
    done
    #print -rl "${ZKL_INDEX_ZEKYLLS[@]}"
}

#
# Returns array of file names of files that
# belong to current index
#
get_files_of_index() {
    local -a filter
    filter=( "${ZKL_INDEX_ZEKYLLS[@]//*(#m)/$MATCH.*}" )
    reply=( $^~filter(N) )
}

# Checks what possible files in index exist,
# counts them and checks for holes - which
# would mean inconsistency
#
# It also returns the files
compute_index_size_check_consistency() {
    local -a files

    get_files_of_index

    # Save for return
    local -a files
    files=( "${reply[@]}" )

    # Focus on listing?
    integer listing=0
    [ "$2" = "-f" ] && listing=1

    # Will work on reply
    integer size=${#reply} start_size end_size end=0 consistent=1
    local zzz
    for zzz in "${ZKL_INDEX_ZEKYLLS[@]}"; do
        start_size="${#reply}"
        reply=( "${reply[@]:#$zzz.*(#m)}" )
        end_size="${#reply}"

        #echo "start_size vs end_size - $start_size vs $end_size"
        if [[ "$start_size" -eq "$end_size" ]]; then
            # No match -> end
            end=1
        else
            # Match: must not have been ended earlier
            if (( end == 1 )); then
                if (( listing == 0 )); then
                    # Normal mode: report inconsistent files
                    if [[ "$consistent" -eq "1" ]]; then
                        files=( "$MATCH" )
                        consistent=0
                    else
                        files+=( "$MATCH" )
                    fi
                else
                    # Listing mode: report all files
                    consistent=0
                    break
                fi
            fi
        fi

        if [[ "$end_size" -eq 0 ]]; then
            break
        fi
    done

    REPLY="${#files}"
    reply=( "${files[@]}" )

    return $(( 1-consistent ))
}

# $1 - bits decoded from zcode
# $REPLY = bits to skip
# $reply = ( ref, file, repo, wordref, unused, error )
process_meta_data() {
    local -a bits
    bits=( "$@" )
    integer size="$#"

    bits=( "${(Oa)bits[@]}" )
    local strbits="${(j::)bits}"
    integer init_len="${#strbits}"

    local -A decoded
    decoded=(
        ref ""
        file ""
        repo ""
        wordref ""
        unused ""
        error ""
    )

    # Is there SS?
    if [ "${strbits[1,${#codes[ss]}]}" = "${codes[ss]}" ]; then
        strbits="${strbits[${#codes[ss]}+1,-1]}"
        # Is there immediate following SS?
        if [ "${strbits[1,${#codes[ss]}]}" = "${codes[ss]}" ]; then
            # We should skip one SS and there is nothing to decode
            REPLY="${#codes[ss]}"
            reply=( "" "" "" "" "" "" )
            return 0
        fi

        #
        # Follows meta data, decode it
        #

        # ref, file, repo, wordref, unused or error
        local current_selector="error"
        integer trylen
        local mat trystr
        while (( 1 )); do
            mat=""
            for (( trylen=1; trylen <= 6; trylen ++ )); do
                # Take substring of len $trylen and check if
                # it mates any Huffman code
                trystr="${strbits[1,trylen]}"
                mat="${rcodes[$trystr]}"
                [ -n "$mat" ] && break
            done

            # General failure in decoding the string
            if [ -z "$mat" ]; then
                REPLY="-1"
                reply=( "" "" "" "" "" "" )
                return 1
            fi

            # Skip decoded bits
            strbits="${strbits[trylen+1,-1]}"

            # Handle what has been matched, either selector or data
            case "$mat" in
                (ss)
                    break
                    ;;
                (ref)
                    current_selector="ref"
                    ;;
                (file)
                    current_selector="file"
                    ;;
                (repo)
                    current_selector="repo"
                    ;;
                (wordref)
                    current_selector="wordref"
                    ;;
                (unused)
                    current_selector="unused"
                    ;;
                (*)
                    # File names use "/" to encode "." character. "/" itself is unavailable
                    [[ "$mat" = "/" && "$current_selector" = "file" ]] && mat="."
                    decoded[$current_selector]+="$mat"
                    ;;
            esac
        done

        REPLY="$(( init_len - ${#strbits} ))"
        reply=( "${decoded[ref]}" "${decoded[file]}" "${decoded[repo]}" "${decoded[wordref]}" "${decoded[unused]}" "${decoded[error]}" )
    else
        # No meta data and no special ending of zekyll bits
        REPLY="0"
        reply=( "" "" "" "" "" "" )
    fi

    return 0
}

#
# Gets zekylls for given code ($1)
# Also gets meta data: ref, file, repo
# and puts it into $reply array
#
get_zekylls_for_code() {
    local zcode="$1"
    decode_zcode "$zcode"

    local -a bits
    bits=( "${reply[@]}" )

    process_meta_data "${bits[@]}"
    # $reply contains: ref, file, repo, wordref, unused, error
    # $REPLY contains: number of final bits that contained the meta data
    local -a meta_reply
    meta_reply=( "${reply[@]}" )

    # Skip bits that were processed as meta data
    bits=( "${(@)bits[1,-1*REPLY-1]}" )
    integer size="${#bits}"

    # Last zekyll from $reply is first zekyll
    # in ZKL_INDEX_ZEKYLLS, thus the size-i+1
    # Less significant bit is first zekyll
    integer i
    local zekylls
    for (( i=size; i>=1; i-- )); do
        if [ "${bits[i]}" = "1" ]; then
            zekylls+="${ZKL_INDEX_ZEKYLLS[size-i+1]}"
        fi
    done

    REPLY="$zekylls"
    reply=( "${meta_reply[@]}" )
}

# vim:ft=zsh
