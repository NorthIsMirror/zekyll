# Helper functions
pinfo() { print "${fg_bold[green]}$*$reset_color"; }
pinfon() { print -n "${fg_bold[green]}$*$reset_color"; }
pinfo2() { print "${fg_bold[yellow]}$*$reset_color"; }
pinfo2n() { print -n "${fg_bold[yellow]}$*$reset_color"; }
perror() { print "${fg_bold[red]}$*$reset_color" >&2; }
perrorn() { print -n "${fg_bold[red]}$*$reset_color" >&2; }
clearinput() { repeat 10; do read -rs -k 1 -t; done; }

#
# Standard outputs
#

dry-mode-msg() { [ "$ZKL_PERFORM_WRITE" = "0" ] && pinfo2 "= Dry mode =" || perror "= Actual mode (not-dry) ="; }
help-opts(){ pinfo "Options are:"; }
help-cd()  { print -- "-c/--cd             -- ask for working directory, otherwise it's current directory"; }
help-dry() { print -- "-w/--write          -- actual operation mode - else it is always dry-run mode"; }
help-git() { print -- "-g/--git            -- perform operations with git (to update repository not just files)"; }
help-path(){ print -- "-p/--path [path]    -- work in given path (don't ask for it)"; }
help-zkl() { print -- "-z/--zkl [zekylls]  -- process given zekylls"; }
help-dft() { print -- "-d/--default        -- use ZEKYLL_DEFAULT_REPO if available as working directory (don't ask)"; }
help-repo(){ print -- "-r/--repo           -- use given repo as path specification"; }

#
# Detects duplicates in given array
#

detect_duplicates() {
    local -a sorted
    sorted=( "${(on)@}" )

    integer dups=0

    local prev="" i
    for i in "${sorted[@]}"; do
        if [ "$prev" = "$i" ]; then
            echo "Duplicate zekyll found: $i" >&2
            dups=1
        fi
        prev="$i"
    done

    return $dups
}

#
# Read destination path
#

read_destination_path() {
    local zekylls_path="$1"

    while (( 1 )); do
        pinfo "Where are zekylls located? (default: current directory \".\"):"

        vared -cp "Enter path: " zekylls_path

        if [ -z "$zekylls_path" ]; then
            zekylls_path="."
        fi

        if ! test -d "$zekylls_path"; then
            perror "Path doesn't exist, try again"
            continue
        fi

        break
    done

    REPLY="$zekylls_path"
    return 0
}

#
# Read repository spec
#

read_repo() {
    local repo_spec="$1"

    while (( 1 )); do
        vared -cp "Enter user/name or just user: " repo_spec

        if [[ "$repo_spec" != [a-zA-Z0-9][a-zA-Z0-9-]#[/][a-zA-Z0-9_-]## && "$repo_spec" != [a-zA-Z0-9][a-zA-Z0-9-]# ]]; then
            perror "Incorrect repository spec. It can contain letters, numbers, underscores and hyphens."
            continue
        fi

        get_path_from_repo "$repo_spec"
        if ! test -d "$REPLY"; then
            perror "Repository doesn't exist, try again"
            continue
        fi

        break
    done

    REPLY="$repo_spec"

    return 0
}

#
# Resolves path according to various rules and sources
#
resolve_path() {
    # If -d/--default is given, then this means: do exactly the
    # same but without prompting for path, but fallback to this
    # if ZEKYLL_DEFAULT_REPO is empty (or when ZKL_PATH is set
    # meaning user provided a path; this is used in zkl-mv where
    # prompt might be demanded even with path provided, via -c
    # option; other tools don't call this function when they
    # already have path)

    integer ask=1
    [ "$ZKL_DEFAULT" = 1 ] && ask=0
    [[ -z "$ZEKYLL_DEFAULT_REPO" || -n "$ZKL_PATH" ]] && ask=1

    [[ -n "$ZEKYLL_DEFAULT_REPO" && -z "$ZKL_PATH" ]] && { get_path_from_repo "$ZEKYLL_DEFAULT_REPO"; ZKL_PATH="$REPLY"; }

    (( ask )) && { read_destination_path "$ZKL_PATH" || exit 1 }
}

#
# This function translates repo to path, but
# also asks for the repo if conditions are
# meet
#
resolve_repo() {
    integer ask=1
    [[ "$ZKL_DEFAULT" = 1 && -n "$ZEKYLL_DEFAULT_REPO" ]] && ask=0
    [ -n "$ZKL_REPO" ] && ask=0

    # -r/--repo has precedence
    local repo="$ZEKYLL_DEFAULT_REPO"
    [ -n "$ZKL_REPO" ] && repo="$ZKL_REPO"

    if (( ask )); then
        # Will propose the repo (if it's set)
        read_repo "$repo" || exit 1
        repo="$REPLY"
    fi

    get_path_from_repo "$repo"
}

#
# CD to path and show files there
#
cd_will_work_on() {
    [ -d "$1" ] || { perror "Error: path doesn't exist"; return 1 }

    cd "$1"

    # Silent mode
    [ "$2" = "-s" ] && return 0

    print
    pinfo2 "Will work on following files:"
    print

    local -a listing
    listing=( "${(@f)"$( ls -1 | pr -3 -e8 -f -l 1000 -t)"}" )
    listing=( "${listing[@]:#*$'\C-L'*}" )
    print -rl -- "${listing[@]}"

    print

    return 0
}

#
# Returns physicall path for given repo string
#
get_path_from_repo() {
    local user="${1%/*}"
    local repo="${1#*/}"

    # No repo given? Use "zkl"
    if [ "${1//\//}" = "$1" ]; then
        repo="zkl"
    fi

    REPLY="$ZKL_REPOS_DIR/${user}---${repo}"
}

#
# Returns physicall path for given user and repo
#
get_path_from_user_repo() {
    [ "$2" = "" ] && 2="zkl"
    REPLY="$ZKL_REPOS_DIR/${1}---${2}"
}

# vim:ft=zsh
