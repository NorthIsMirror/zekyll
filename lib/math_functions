setopt typesetsilent

local -a characters
characters=( a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 )

#
# Converts each character of input string into number 0..35
#
letters_to_numbers() {
    local letters="$1" l
    integer number
    reply=( )
    for l in "${(@s::)letters}"; do
        number="${characters[(i)$l]}"
        number=number-1
        reply+=( "$number" )
    done
}

#
# Converts array of numbers into string [a-z0-9]+
#
numbers_to_letters() {
    REPLY=""
    integer i
    for i in "$@"; do
        REPLY+="${characters[i+1]}"
    done
}

#
# Takes zekyl code, i.e. 1/someletters
# and decodes it to series of zekylls
#
decode_zcode() {
    local number="${1%/*}"
    local letters="${1#*/}"

    if [ "$1" = "${1//\//}" ]; then
        # Improper zcode
        return 1
    fi

    # Compute first element pointed to by index
    integer first=$(( (number-1)*150 + 1 ))

    # The zcode can have at most 30 digits
    # This is the 150 bits (150 zekylls)
    # written in base 36. We have to obtain
    # the 150 bits. We will implement division
    # in base 36 and gradually obtain the 150 bits.

    local -a bits
    local workingvar="$letters"
    while [ "${workingvar//a/}" != "" ]; do
        div2 "$workingvar"
        workingvar="${reply[1]}"
        bits=( "${reply[2]}" "${bits[@]}" )
        #echo "After div $workingvar/${reply[2]}"
    done
    #echo "Bits of the letters $letters are: ${(j::)bits[@]}"
}

#
# Takes string of 0 and 1 that mark which zekylls are active
# and encodes it to base 36 number expressed via a-z0-9
#
encode_zcode() {
    local str01="$1"

    local -a numbers
    str_01_to_8-bit_pack_numbers "$str01"
    numbers=( "${reply[@]}" )

    local -a nums_base36 workingvar
    workingvar=( "${numbers[@]}" )

    integer sum=0 i
    for i in "${workingvar[@]}"; do
        sum+=i
    done

    while (( sum != 0 )); do
        div_8-bit_pack_numbers_36 "${workingvar[@]}"
        workingvar=( "${reply[@]}" )
        nums_base36=( "$REPLY" "${nums_base36[@]}" )

        # Check if workingvar is all zero
        sum=0
        for i in "${workingvar[@]}"; do
            sum+=i
        done
    done

    # echo "Base36 numbers of $str01 are: ${(j:,:)nums_base36[@]}"
    reply=( "${nums_base36[@]}" )
}

# $1 - zcode's letters
# $reply - ( "zcode's letters after division" "remainder 0 or 1" )
div2() {

    #
    # First translate the letters to numbers and put them into array
    #

    local letters="$1"
    local -a numbers
    letters_to_numbers "$letters"
    numbers=( "${reply[@]}" )

    #
    # Now operate on the array performing long-division
    #

    integer cur last
    cur=1
    last="${#numbers}"

    local -a result
    result=()

    integer prepared_for_division="${numbers[cur]}"
    while (( 1 )); do
        integer quotient=prepared_for_division/2

        result+=( "$quotient" )

        integer recovered=quotient*2
        integer subtracted=prepared_for_division-recovered

        cur+=1
        if (( cur > last )); then
            break
        fi

        prepared_for_division=36*subtracted+${numbers[cur]}
    done

    #
    # Now convert the result to letters
    #

    numbers_to_letters "${result[@]}"

    #
    # Return
    #

    reply=( "$REPLY" "$subtracted" )

    return 0
}


#
# Takes STRING of 0 and 1 and converts it to array of numbers
# that are 8-bit packs taken from right to left, from the string
#
str_01_to_8-bit_pack_numbers() {
    local -a bits
    bits=( "${(@s::)1}" )
    arr_01_to_8-bit_pack_numbers "${bits[@]}"

    return 0
}

#
# Takes ARRAY (@) of 0 and 1 and converts it to array of numbers
# that are 8-bit packs taken from right to left, from the string
#
arr_01_to_8-bit_pack_numbers() {
    local -a bits pack numbers
    bits=( "$@" )
    integer count=0 i size="${#bits}"

    # Take packs of 8 bits, convert each to number and store in array
    for (( i=size; i>=1; i-- )); do
        pack=( "$bits[i]" "${pack[@]}" )
        count+=1
        (( count < 8 && i != 1 )) && continue
        count=0

        # Convert the max. 8 bit pack to number
        integer result=0 p
        for p in "${pack[@]}"; do
            result=result*2+p
        done

        numbers=( "$result" "${numbers[@]}" )
        pack=( )
    done

    reply=( "${numbers[@]}" )
    return 0
}

# $1 - series of 0 and 1 (bits marking which zekyll is active)
# $reply - ( "series of 0 and 1, result of division" "remainder 0 ... 35" )
div_8-bit_pack_numbers_36() {
    local -a numbers
    numbers=( "$@" )

    # echo "Dividing numbers: " "${numbers[@]}"

    #
    # Now operate on the array performing long-division
    #

    integer cur last
    cur=1
    last="${#numbers}"

    local -a result
    result=()

    integer prepared_for_division="${numbers[cur]}"
    while (( 1 )); do
        integer quotient=prepared_for_division/36

        result+=( "$quotient" )

        integer recovered=quotient*36
        integer subtracted=prepared_for_division-recovered

        cur+=1
        if (( cur > last )); then
            break
        fi

        prepared_for_division=256*subtracted+${numbers[cur]}
    done

    # echo "Result of division: " "${result[@]}"
    # echo "Remainder: $subtracted"

    #
    # Return
    #

    reply=( "${result[@]}" )
    REPLY="$subtracted"

    return 0
}

#
# Takes number in $1, returns string [a-z0-9]+
# that is representation of the number in base 36
#
convert_integer_to_base_36() {
    integer number="$1"
    local -a digits

    integer new_number=number
    integer remainder
    while (( new_number != 0 )); do
        remainder=new_number%36
        new_number=new_number/36

        digits+=( "$remainder" )
    done

    [[ "${#digits}" -eq 0 ]] && digits+=( 0 )
    [[ "${#digits}" -eq 1 ]] && digits+=( 0 )
    [[ "${#digits}" -eq 2 ]] && digits+=( 0 )

    digits=( "${(Oa)digits[@]}" )

    numbers_to_letters "${digits[@]}"
}

# vim:ft=zsh
